[
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "",
    "text": "I have been working on a better understanding of the GDAL multidimensional model and to do that really needs a closer look at the GDAL API itself.\nThis post demonstrates loading the GDAL API via its Python bindings into R. We connect to a modern “cloud-ready” ZARR dataset, find out some details about its contents and then convert from its native multidimensional form to a more classic 2D raster model, then use that to create a map from Sentinel 2 imagery.\nWe don’t go very deep into any part, but just want to show a quick tour of some parts of GDAL that don’t get as much attention as deserved (IMO). I’m using a very recent version of GDAL, which might mean some code doesn’t work for you. If that’s the case please let me know and I can explore alternatives and identify when/how the newer features will be more available. There are some echoes here of an older post I made about GDAL in R: https://www.hypertidy.org/posts/2017-09-01_gdal-in-r/"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#the-gdal-api",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#the-gdal-api",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "",
    "text": "I have been working on a better understanding of the GDAL multidimensional model and to do that really needs a closer look at the GDAL API itself.\nThis post demonstrates loading the GDAL API via its Python bindings into R. We connect to a modern “cloud-ready” ZARR dataset, find out some details about its contents and then convert from its native multidimensional form to a more classic 2D raster model, then use that to create a map from Sentinel 2 imagery.\nWe don’t go very deep into any part, but just want to show a quick tour of some parts of GDAL that don’t get as much attention as deserved (IMO). I’m using a very recent version of GDAL, which might mean some code doesn’t work for you. If that’s the case please let me know and I can explore alternatives and identify when/how the newer features will be more available. There are some echoes here of an older post I made about GDAL in R: https://www.hypertidy.org/posts/2017-09-01_gdal-in-r/"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#zarr-and-the-european-space-agency-esa",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#zarr-and-the-european-space-agency-esa",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "ZARR and the European Space Agency (ESA)",
    "text": "ZARR and the European Space Agency (ESA)\nThe ESA is moving Copernicus to ZARR, launching its Earth Observation Processing Framework (EOPF) data format (Zarr). ZARR is “a community project to develop specifications and software for storage of large N-dimensional typed arrays”.\nA ZARR is a dataset consisting of trees of array chunks stored (usually) in object storage and indexed by fairly simple JSON metadata that describes how those chunks align together in one potentially very large array. The idea is that all the metadata lives upfront in instantly readable JSON, and changes made to the dataset (extending it each day as new data arrives) affects only the relevant chunks and the small parts of the JSON. This is different to a long list of NetCDFs that grows every day, where the metadata is self-contained for each file and there is no overarching abstraction for the entire file set.\nZARR is usually in object storage, and loaded by datacube software such as xarray. It’s not intended to be zipped into a huge file and downloaded or read, the real power lies in the entire dataset being lazy, and understood by software that needs just one data set description (url, or S3 path, etc)."
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#esa-sample-zarr-datasets",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#esa-sample-zarr-datasets",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "ESA sample Zarr datasets",
    "text": "ESA sample Zarr datasets\nThe ESA provide a set of example ZARRs that are available in zip files:\nhttps://eopf-public.s3.sbg.perf.cloud.ovh.net/product.html\nWe choose one that is described by this URL:\n\nurl &lt;- \"https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\""
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-urls-and-zip-files",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-urls-and-zip-files",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "GDAL urls and zip files",
    "text": "GDAL urls and zip files\nGDAL doesn’t force us to download data, but we need some syntax to leverage its remote capabilities in the simplest way. The Virtual File System (VSI) allows us to declare special sources like zip files /vsizip/ and urls /vsicurl/, which we can chain together. With ZARR we also need careful quoting of the description, and we declare the ZARR driver upfront.\n\n(dsn &lt;- sprintf('ZARR:\"/vsizip//vsicurl/%s\"', url))\n\n[1] \"ZARR:\\\"/vsizip//vsicurl/https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\\\"\""
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-and-multidimensional-datasets",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-and-multidimensional-datasets",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "GDAL and multidimensional datasets",
    "text": "GDAL and multidimensional datasets\nGDAL has a multidimensional mode for data sources that aren’t “imagery” in the traditional sense. (If we open one of these datasets in “classic” mode we end up with a lot of bands on a 2D raster, or potentially many bands on many subdatasets within a more general container. Zarr is a container format, much like HDF5 and NetCDF).\nMultidimensional mode is avaible in the API via OpenEx() and declaring type OF_MULTIDIM_RASTER.\nTo actually load this python library we use {reticulate} py_require() which drives the awesome Python uv package manager.\n(For some reason the pypi name of the package is “gdal”, but the actual module is obtained with “osgeo.gdal”).\n\nreticulate::py_require(\"gdal\")\ngdal &lt;- reticulate::import(\"osgeo.gdal\")\ngdal$UseExceptions()\n\nsample(names(gdal), 40)  ## see that we have a huge coverage of the underlying API, 544 elements at time of writing\n\n [1] \"SetErrorHandler\"                          \n [2] \"GRTT_THEMATIC\"                            \n [3] \"SubdatasetInfo\"                           \n [4] \"GetNextDirEntry\"                          \n [5] \"GDT_Unknown\"                              \n [6] \"DontUseExceptions\"                        \n [7] \"GDT_Int64\"                                \n [8] \"ApplyVerticalShiftGrid\"                   \n [9] \"SetConfigOption\"                          \n[10] \"GDAL_GCP_GCPX_get\"                        \n[11] \"GetColorInterpretationName\"               \n[12] \"GCI_LWIRBand\"                             \n[13] \"RasterizeOptions\"                         \n[14] \"VirtualMem\"                               \n[15] \"ReadDirRecursive\"                         \n[16] \"GCI_OtherIRBand\"                          \n[17] \"CE_Fatal\"                                 \n[18] \"DCAP_NOTNULL_GEOMFIELDS\"                  \n[19] \"Relationship\"                             \n[20] \"UseExceptions\"                            \n[21] \"GFU_MinMax\"                               \n[22] \"GRA_Sum\"                                  \n[23] \"DIM_TYPE_PARAMETRIC\"                      \n[24] \"GDALFootprintOptions\"                     \n[25] \"CreatePansharpenedVRT\"                    \n[26] \"GDAL_DMD_RELATIONSHIP_RELATED_TABLE_TYPES\"\n[27] \"CE_Failure\"                               \n[28] \"GCI_HueBand\"                              \n[29] \"DMD_NUMERIC_FIELD_WIDTH_INCLUDES_SIGN\"    \n[30] \"MajorObject\"                              \n[31] \"wrapper_GDALFootprintDestName\"            \n[32] \"GFU_Generic\"                              \n[33] \"GEDTC_COMPOUND\"                           \n[34] \"GRA_Max\"                                  \n[35] \"GDAL_DCAP_CREATE_RELATIONSHIP\"            \n[36] \"DMD_MULTIDIM_GROUP_CREATIONOPTIONLIST\"    \n[37] \"GRC_ONE_TO_MANY\"                          \n[38] \"DMD_CREATION_FIELD_DOMAIN_TYPES\"          \n[39] \"GRIORA_Average\"                           \n[40] \"DMD_ALTER_GEOM_FIELD_DEFN_FLAGS\"          \n\n\nThe API elements chain in the usual way that works in python with ‘object.element.thing.etc’ syntax uses R’s $ accessor.\n\ngdal$Dimension$GetIndexingVariable\n\n&lt;function Dimension.GetIndexingVariable at 0x7f690c8f5760&gt;\n signature: (self, *args) -&gt; 'GDALMDArrayHS *'"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#open-the-data",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#open-the-data",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "Open the data",
    "text": "Open the data\nIt’s not very exciting yet.\n\nds &lt;- gdal$OpenEx(dsn, gdal$OF_MULTIDIM_RASTER)\nds\n\n&lt;osgeo.gdal.Dataset; proxy of &lt;Swig Object of type 'GDALDatasetShadow *' at 0x7f690ca873f0&gt; &gt;\n\n\nTo actually find out what’s in there we have to traverse a tree of potentially nested “groups” that organize actual datasets in a hierarchy.\nGet the root group and dive in, it’s very tediuous but shows some of what is there. There might be MDArrays in a group, or there might just be more groups.\n\nrg &lt;- ds$GetRootGroup()\nrg$GetMDArrayNames()\n\nlist()\n\nrg$GetGroupNames()\n\n[1] \"conditions\"   \"measurements\" \"quality\"     \n\ng1 &lt;- rg$OpenGroup(\"quality\")\ng1$GetMDArrayNames()\n\nlist()\n\ng1$GetGroupNames()\n\n[1] \"l1c_quicklook\" \"mask\"         \n\ng2 &lt;- g1$OpenGroup(\"l1c_quicklook\")\ng2$GetMDArrayNames()\n\nlist()\n\ng2$GetGroupNames()\n\n[1] \"r10m\"\n\ng3 &lt;- g2$OpenGroup(\"r10m\")\ng3$GetMDArrayNames()\n\n[1] \"band\" \"x\"    \"y\"    \"tci\" \n\ng3$GetGroupNames()\n\nlist()\n\n\nFinally we got to actual data, we recognize ‘tci’ as being the quicklook RGB of Sentinel 2.\nTo avoid tedium write a quick recursive function to find all the MDArray, at each level use GetFullName() which provides the cumulative path to where we are in the tree.\n\nget_all_mdnames &lt;- function(rootgroup) {\n  groups &lt;- rootgroup$GetGroupNames()\n  groupname &lt;- rootgroup$GetFullName()\n  amd &lt;- rootgroup$GetMDArrayNames()\n  md &lt;- sprintf(\"%s/%s\", groupname, amd)\n  md &lt;- c(md, unlist(lapply(groups, \\(.g) get_all_mdnames(rootgroup$OpenGroup(.g)))))\n  md\n}\n\nget_all_mdnames(ds$GetRootGroup())\n\n  [1] \"/conditions/geometry/angle\"                        \n  [2] \"/conditions/geometry/band\"                         \n  [3] \"/conditions/geometry/detector\"                     \n  [4] \"/conditions/geometry/x\"                            \n  [5] \"/conditions/geometry/y\"                            \n  [6] \"/conditions/geometry/mean_sun_angles\"              \n  [7] \"/conditions/geometry/mean_viewing_incidence_angles\"\n  [8] \"/conditions/geometry/sun_angles\"                   \n  [9] \"/conditions/geometry/viewing_incidence_angles\"     \n [10] \"/conditions/mask/detector_footprint/r10m/x\"        \n [11] \"/conditions/mask/detector_footprint/r10m/y\"        \n [12] \"/conditions/mask/detector_footprint/r10m/b02\"      \n [13] \"/conditions/mask/detector_footprint/r10m/b03\"      \n [14] \"/conditions/mask/detector_footprint/r10m/b04\"      \n [15] \"/conditions/mask/detector_footprint/r10m/b08\"      \n [16] \"/conditions/mask/detector_footprint/r20m/x\"        \n [17] \"/conditions/mask/detector_footprint/r20m/y\"        \n [18] \"/conditions/mask/detector_footprint/r20m/b05\"      \n [19] \"/conditions/mask/detector_footprint/r20m/b06\"      \n [20] \"/conditions/mask/detector_footprint/r20m/b07\"      \n [21] \"/conditions/mask/detector_footprint/r20m/b11\"      \n [22] \"/conditions/mask/detector_footprint/r20m/b12\"      \n [23] \"/conditions/mask/detector_footprint/r20m/b8a\"      \n [24] \"/conditions/mask/detector_footprint/r60m/x\"        \n [25] \"/conditions/mask/detector_footprint/r60m/y\"        \n [26] \"/conditions/mask/detector_footprint/r60m/b01\"      \n [27] \"/conditions/mask/detector_footprint/r60m/b09\"      \n [28] \"/conditions/mask/detector_footprint/r60m/b10\"      \n [29] \"/conditions/mask/l1c_classification/r60m/x\"        \n [30] \"/conditions/mask/l1c_classification/r60m/y\"        \n [31] \"/conditions/mask/l1c_classification/r60m/b00\"      \n [32] \"/conditions/meteorology/cams/latitude\"             \n [33] \"/conditions/meteorology/cams/longitude\"            \n [34] \"/conditions/meteorology/cams/aod1240\"              \n [35] \"/conditions/meteorology/cams/aod469\"               \n [36] \"/conditions/meteorology/cams/aod550\"               \n [37] \"/conditions/meteorology/cams/aod670\"               \n [38] \"/conditions/meteorology/cams/aod865\"               \n [39] \"/conditions/meteorology/cams/bcaod550\"             \n [40] \"/conditions/meteorology/cams/duaod550\"             \n [41] \"/conditions/meteorology/cams/isobaricInhPa\"        \n [42] \"/conditions/meteorology/cams/number\"               \n [43] \"/conditions/meteorology/cams/omaod550\"             \n [44] \"/conditions/meteorology/cams/ssaod550\"             \n [45] \"/conditions/meteorology/cams/step\"                 \n [46] \"/conditions/meteorology/cams/suaod550\"             \n [47] \"/conditions/meteorology/cams/surface\"              \n [48] \"/conditions/meteorology/cams/time\"                 \n [49] \"/conditions/meteorology/cams/valid_time\"           \n [50] \"/conditions/meteorology/cams/z\"                    \n [51] \"/conditions/meteorology/ecmwf/latitude\"            \n [52] \"/conditions/meteorology/ecmwf/longitude\"           \n [53] \"/conditions/meteorology/ecmwf/isobaricInhPa\"       \n [54] \"/conditions/meteorology/ecmwf/msl\"                 \n [55] \"/conditions/meteorology/ecmwf/number\"              \n [56] \"/conditions/meteorology/ecmwf/r\"                   \n [57] \"/conditions/meteorology/ecmwf/step\"                \n [58] \"/conditions/meteorology/ecmwf/surface\"             \n [59] \"/conditions/meteorology/ecmwf/tco3\"                \n [60] \"/conditions/meteorology/ecmwf/tcwv\"                \n [61] \"/conditions/meteorology/ecmwf/time\"                \n [62] \"/conditions/meteorology/ecmwf/u10\"                 \n [63] \"/conditions/meteorology/ecmwf/v10\"                 \n [64] \"/conditions/meteorology/ecmwf/valid_time\"          \n [65] \"/measurements/reflectance/r10m/x\"                  \n [66] \"/measurements/reflectance/r10m/y\"                  \n [67] \"/measurements/reflectance/r10m/b02\"                \n [68] \"/measurements/reflectance/r10m/b03\"                \n [69] \"/measurements/reflectance/r10m/b04\"                \n [70] \"/measurements/reflectance/r10m/b08\"                \n [71] \"/measurements/reflectance/r20m/x\"                  \n [72] \"/measurements/reflectance/r20m/y\"                  \n [73] \"/measurements/reflectance/r20m/b05\"                \n [74] \"/measurements/reflectance/r20m/b06\"                \n [75] \"/measurements/reflectance/r20m/b07\"                \n [76] \"/measurements/reflectance/r20m/b11\"                \n [77] \"/measurements/reflectance/r20m/b12\"                \n [78] \"/measurements/reflectance/r20m/b8a\"                \n [79] \"/measurements/reflectance/r60m/x\"                  \n [80] \"/measurements/reflectance/r60m/y\"                  \n [81] \"/measurements/reflectance/r60m/b01\"                \n [82] \"/measurements/reflectance/r60m/b09\"                \n [83] \"/measurements/reflectance/r60m/b10\"                \n [84] \"/quality/l1c_quicklook/r10m/band\"                  \n [85] \"/quality/l1c_quicklook/r10m/x\"                     \n [86] \"/quality/l1c_quicklook/r10m/y\"                     \n [87] \"/quality/l1c_quicklook/r10m/tci\"                   \n [88] \"/quality/mask/r10m/x\"                              \n [89] \"/quality/mask/r10m/y\"                              \n [90] \"/quality/mask/r10m/b02\"                            \n [91] \"/quality/mask/r10m/b03\"                            \n [92] \"/quality/mask/r10m/b04\"                            \n [93] \"/quality/mask/r10m/b08\"                            \n [94] \"/quality/mask/r20m/x\"                              \n [95] \"/quality/mask/r20m/y\"                              \n [96] \"/quality/mask/r20m/b05\"                            \n [97] \"/quality/mask/r20m/b06\"                            \n [98] \"/quality/mask/r20m/b07\"                            \n [99] \"/quality/mask/r20m/b11\"                            \n[100] \"/quality/mask/r20m/b12\"                            \n[101] \"/quality/mask/r20m/b8a\"                            \n[102] \"/quality/mask/r60m/x\"                              \n[103] \"/quality/mask/r60m/y\"                              \n[104] \"/quality/mask/r60m/b01\"                            \n[105] \"/quality/mask/r60m/b09\"                            \n[106] \"/quality/mask/r60m/b10\"                            \n\n\nHappily, we see our target MDArray name in there /quality/l1c_quicklook/r10m/tci."
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#actual-data",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#actual-data",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "Actual data",
    "text": "Actual data\nFinally let’s get some data out. We can obtain the MDArray now by full name and find out some properties.\n\nreticulate::py_require(\"gdal\")\ngdal &lt;- reticulate::import(\"osgeo.gdal\")\ngdal$UseExceptions()\n\ndsn &lt;- \"ZARR:\\\"/vsizip//vsicurl/https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\\\"\"\n\nds &lt;- gdal$OpenEx(dsn, gdal$OF_MULTIDIM_RASTER)\nrg &lt;- ds$GetRootGroup()\nmdname &lt;- \"/quality/l1c_quicklook/r10m/tci\"\nmd &lt;- rg$OpenMDArrayFromFullname(mdname)\nmd$GetDimensionCount()\n\n[1] 3\n\n\nTraverse the dimensions to get their sizes and names.\n\nvapply(md$GetDimensions(), \\(.d) .d$GetSize(), 0L)\n\n[1]     3 10980 10980\n\nvapply(md$GetDimensions(), \\(.d) .d$GetName(), \"\")\n\n[1] \"band\" \"y\"    \"x\"   \n\n\nExplore some metadata attributes.\n\nmnames &lt;- vapply(md$GetAttributes(), \\(.a) .a$GetName(), \"\")\n\n(meta &lt;- setNames(lapply(md$GetAttributes(), \\(.a) unlist(.a$Read())), mnames))\n\n$long_name\n[1] \"TCI: True Color Image\"\n\n$`proj:bbox`\n[1]  300000 4490220  409800 4600020\n\n$`proj:epsg`\n[1] 32636\n\n$`proj:shape`\n[1] 10980 10980\n\n$`proj:transform`\n[1]      10       0  300000       0     -10 4600020       0       0       1\n\n$`proj:wkt2`\n[1] \"PROJCS[\\\"WGS 84 / UTM zone 36N\\\",GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",33],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32636\\\"]]\"\n\n\nWe see that the CRS information is in there, but sadly while the geotransform of the data is maintained when we convert to classic raster the CRS does not make the journey (the geotransform is just the image bbox intermingled with its resolution in a mathematical abstraction used in matrix manipulation).\nA multidim raster can be converted to classic form, either in whole or after applying a $GetView() operation that acts like numpy ‘[:]’ array subsetting.\nWhen converting to classic raster we specify the x, then y dimensions of the dataset, which from multdim convention are in reverse order. (Note that dimension 0 is the “3rd” dimension in normal thinking, here that dimension is “band” or a dimension for each of red, green, blue in the quicklook image).\n\ncc &lt;- md$AsClassicDataset(2L, 1L)\ntr &lt;- unlist(cc$GetGeoTransform())\ndm &lt;- c(cc$RasterXSize, cc$RasterYSize)\ncc$GetSpatialRef() ## empty, so we retrieve from the attributes\ncrs &lt;- cc$GetMetadata()[[\"proj:wkt2\"]]\n\nNow, I used reproj_extent to convert the dataset’s bbox to one in longlat, but I won’t share that here, we’ll just use the result so our map is a little more familiar. The source data xy bbox is xmin: 300000 ymin: 4490220  xmax: 409800 ymax:4600020, and we take small section of that which is this in longitude latitude:\n\n# xmin,xmax,ymin,ymax converted below to bbox \nex &lt;- c(31.689, 31.774, 40.665, 40.724)\n\nTo warp the imagery to this region we first need to set the CRS properly on the dataset, so translate to a temporary VRT and use that dataset for the next step.\n\ndsvrt &lt;- gdal$Translate(tempfile(fileext = \".vrt\", tmpdir = \"/vsimem\"), cc, options = c(\"-a_srs\", crs))\ntf &lt;- tf &lt;- \"/vsimem/result.tif\"\nww &lt;- gdal$Warp(tf, dsvrt,  dstSRS = \"EPSG:4326\", outputBounds = ex[c(1, 3, 2, 4)])\nww$Close()\n\n[1] 0\n\n\nFinally we can read the image, plot it, obtain some contextual data and be assured that our map is correct.\n\nlibrary(gdalraster)\ndata &lt;- read_ds(new(GDALRaster, tf))\n\n\nlibrary(osmdata)\nx &lt;- opq(ex[c(1, 3, 2, 4)]) |&gt; add_osm_feature(key = \"highway\") |&gt; osmdata_sf()\n\nlibrary(sf)\nplot_raster(data)\nplot(x$osm_lines[0], add = TRUE, col = \"hotpink\")"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#summary",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#summary",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "Summary",
    "text": "Summary\nWe had a look at GDAL multidimensional API, converting a 3D dataset to classic raster, augmenting the missing CRS information on a virtual copy and then warping an image to a familiar map context.\nThere is ongoing work to bring the full GDAL API to R in {gdalraster}, and in in-development version of gdalraster to add the GDALMultiDimRaster class and helpers: https://github.com/mdsumner/gdalraster/tree/multidimnew.\nPlease get in touch if any of this is of interest!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is a quarto website for the hypertidy family of R packages for multi-dimensional and spatial data.\nHypertidy is an approach to spatial or multi-dimensional data in R based on the following principles:\nExamples of these principles are seen in these R packages.\nvapour\nraadtools and angstroms\ntidync, lazyraster,\nsilicate, anglr, rbgm"
  },
  {
    "objectID": "about.html#gridded-data",
    "href": "about.html#gridded-data",
    "title": "About",
    "section": "Gridded data",
    "text": "Gridded data\nHypertidy recognizes that not all gridded data fit into the GIS raster conventions. Gridded data comes in many forms, geographic with longitude-latitude or projected spaces, with time and or depth dimensions, with different orderings of axes (i.e. time-first, the latitude-longitude), and with generally any arbitrary space. A space is simply a set of axes with particular units and projection, and yes we mean “space” and “projection” in the more general mathematical sense. Date-time data is a projection, there is a mapping of a particular set of values to the real line and the position on that line for particular instant is defined by the axis units and epoch.\nMesh and grid share the same meaning in some contexts."
  },
  {
    "objectID": "about.html#structured-vs.-unstructured-topology-vs.-geometry",
    "href": "about.html#structured-vs.-unstructured-topology-vs.-geometry",
    "title": "About",
    "section": "Structured vs. unstructured, topology vs. geometry",
    "text": "Structured vs. unstructured, topology vs. geometry\nArray-based data have a straight-forward relationship between a set of axes that have discrete steps. These are “structured grids”. Unstructured grids include triangulations, non-regularly binned histograms, tetrahedral meshes and ragged arrays.\nAn unstructured mesh (grid) is able to represent any data structure, but structured meshes have some advantages because of the regular indexing relationship between dimensions.\nGIS vector constructs “polygons”, “lines”, “points” are special case optimizations of the unstructured grid case. Polygons really are topologically identical to lines, and they are a dead-end in the broader scheme of dimensionality. Points and lines can are topologicaly 0-dimensional and 1-dimensional respectively, and this shape-constraint is the same no matter what geometric dimension they are defined in. A line can twist around a 4D space with x, y, z, t coordinates at its segment nodes or it can be constrained to single dimension with only one of those coordinates specifying its position. The topology of the line is completely independent of the geometry, if we treat the line as composed of topological primitives.\nPolygons are not composed of topological primitives, but they can be treated as being composed of line primitives."
  }
]