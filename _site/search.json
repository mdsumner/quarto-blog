[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "hypertidy-blog",
    "section": "",
    "text": "ncurl &lt;- c(‚Äú/vsicurl/https://gws-access.jasmin.ac.uk/public/polarres/MetUM_PolarRES/Antarctic/daily/hfls_ANT-11_ERA5_evaluation_r1i1p1f1_BAS_MetUM_v1-r1_day_20000101_20001231.nc‚Äù,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIDEA - data and software\n\n\n\n\n\n\n\n\n\n\n\nMichael Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nGDAL multidim and cloud-ready ZARR\n\n\n\n\n\n\n\n\n\n\n\nJun 30, 2025\n\n\nMichael Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nConservative regridding with GDAL (?)\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nDec 11, 2024\n\n\nMichael Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nPlot at native resolution, with R\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nDec 4, 2024\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nGDAL and image tiles, the {ceramic} package\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nApr 22, 2023\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nDegenerate Rectilinear (WIP)\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nDec 9, 2022\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nGDAL raster read/write by blocks\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nMay 4, 2022\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nGDAL warper with R\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nApr 25, 2022\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nmesh3d - recent changes in rgl workhorse format\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nMay 29, 2019\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nGDAL in R\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nSep 1, 2017\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nWeb services for scientific data in R\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nJul 25, 2017\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nR spatial in 2017\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nJan 10, 2017\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nGIS for 3D in R\n\n\n\n\n\n\nnews\n\n\ncode\n\n\n\n\n\n\n\n\n\nDec 28, 2015\n\n\nMichael D. Sumner\n\n\n\n\n\n\n\n\n\n\n\n\nR matrices and image\n\n\n\n\n\n\ncode\n\n\n\n\n\n\n\n\n\nApr 17, 2014\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html",
    "href": "posts/2017-01-10_r-spatial-2017/index.html",
    "title": "R spatial in 2017",
    "section": "",
    "text": "This document is a broad overview of what I see as most relevant to future spatial, for 2017 and beyond. I‚Äôve tried to be as broad as possible, without going into too much detail, but it‚Äôs also quite personal and opinionated."
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#the-state-of-things",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#the-state-of-things",
    "title": "R spatial in 2017",
    "section": "The state of things",
    "text": "The state of things\nAn enormous amount of activity has been going on in R spatial. The keystone activity is the new simple features for R package sf, and the many responses to ‚Äúsupporting sf‚Äù in various packages but there are many other non-obvious linkages.\nPersonally, I have learnt quite a lot recently about the broader context within R and I‚Äôm keen to help consolidate some of the ‚Äúnon-central‚Äù tools that we use. There are also some surprisingly helpful implications of the new simple features support both for within the central package, and for the ecosystem around it.\n\nsimple features for R via the sf package\nupcoming replacement for raster\npoint clouds\nmapview and leaflet\nsimple features in other packages\n‚Äúexotic types‚Äù in sf\nspatial data that simple features cannot support\nhtmlwidgets and plotly"
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#sf",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#sf",
    "title": "R spatial in 2017",
    "section": "sf",
    "text": "sf\nThe simple features package sf was one of the first supported projects of the RConsortium and has been created by Edzer Pebesma. This package replaces sp vector data completely, includes a replacement for rgdal and rgeos and there is a long list of important improvements. These are described in full in the package vignettes and blog posts.\nThe key changes relevant here are\n\nno S4 classes, everything is S3 and so is more immediately manipulable/accessible\nmuch better methods support overall, for printing/summary etc.\nthe key objects are list-vectors, and data frames\nsupport for simple features standard, no more ambiguity for multi-polygons/holes, mixed types, NULL geometry, XYZ-M support\nnative support for dplyr verbs, tibbles (some is WIP but group_by/summarize reprojection and geometric union are good examples that already work)\nreprojection and geometry manipulation and file format support is now GDAL 2.0 and GEOS(?), modernized, more reliable, easier\n\nI strongly recommend getting familiar with the sf data structures, it‚Äôs really important to understand the hierarchy levels and the ways the vectors (POINT) and matrices (everything else) are stored. POINT is a vector, MULTIPOINT is a matrix, POLYGON is a list of matrices (one island, zero or more holes), LINESTRING is a matrix (same as m-point), MULTIPOLYGON is a list of lists of matrices (a list of POLYGONs, effectively), and MULTILINESTRING is a list of matrices (a list of LINESTRINGs, effectively and structurally the same as a POLYGON).\nIf you want to see how to convert between sf forms and extract the raw coordinates I would look at st_cast in, and the leaflet approach here:\nhttps://github.com/rstudio/leaflet/blob/master/R/normalize-sf.R"
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#rasters",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#rasters",
    "title": "R spatial in 2017",
    "section": "rasters",
    "text": "rasters\nThe raster package is apparently being significantly upgraded and Edzer has plans for this as well.\nhttp://r-spatial.org/r/2016/09/26/future.html\nThere are some very interesting extensions to raster on CRAN recently, notably velox, fasteraster, and the unrelated but very nice dggridR.\nHDF5 is now fully supported by rhdf5 on Bioconductor, this could also replace many of the NetCDF4 formats supported by ncdf4, and notably can be used to read NetCDF4 files with compound types."
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#point-clouds",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#point-clouds",
    "title": "R spatial in 2017",
    "section": "Point clouds",
    "text": "Point clouds\nA recent contribution on CRAN is rlas and lidR for the LiDaR LAS format, and algorithms for working with point clouds. It is trivial to push these data into sf types, but it won‚Äôt always make sense to do so. You could have a MULTIPOINT with X, Y, Z, and M (but none of the other point attributes) or a point (XYZ) with all the attributes in one sf data frame. This package will be useful for driving interest in the exotic sf types.\nIt‚Äôs easy and readily doable right now to read LIDAR data with rlas, and plot it interactively with RGB styling and so in with plotly. Keen to try writing a ‚Äúdetect ground‚Äù algorithm? Try it! What does st_triangulate do with a XYZ multipoint? (hmm, it fails noisily - you aren‚Äôt supposed to do that)."
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#mapview-and-leaflet",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#mapview-and-leaflet",
    "title": "R spatial in 2017",
    "section": "mapview and leaflet",
    "text": "mapview and leaflet\nmapview has support from RConsortium to bring user interaction to spatial in R. Currently building in support for sf, which will be accelerated by the recent dev upgrades in leaflet itself and will eventually support the range of sf types, including full support for MULTIPOLYGON.\nleaflet now has a huge number of new extensions thanks to leaflet.extras, and there is ongoing updates around integrating crosstalk which will be very importatnt for interactive map applications."
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#simple-features-in-other-packages",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#simple-features-in-other-packages",
    "title": "R spatial in 2017",
    "section": "simple features in other packages",
    "text": "simple features in other packages\ntmap, mapview, spbabel, stplanr, ‚Ä¶. all have internal versions of sf types converted to something else. It‚Äôs an interesting time for these packages that extend the sp and sf structures, and there are opportunities to ensure that best practices are being used."
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#exotic-types-in-sf",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#exotic-types-in-sf",
    "title": "R spatial in 2017",
    "section": "Exotic types in sf",
    "text": "Exotic types in sf\nThese are TINs, Polyhedral Surfaces (multipatch - basically polygons with shared ‚Äúinternal‚Äù edges), curves and various combinations and varieties of these. None of the triangulations use an indexed mesh, which makes them a bit clunky and probably only for very bespoke uses, but they provide interesting territory to explore. Certainly you can use them to build 3D plots in rgl and plotly (show examples, thanks to @timelyportfolio).\nNote that a GEOMETRYCOLLECTION of triangle POLYGONs is effectively the same as a simple features TIN, it doesn‚Äôt really add any structure improvement to the way the thing is put together:\nhttps://github.com/r-gris/sfct\nWe can bend the limits of simple features with ‚Äúmesh‚Äù techniques, and the plotly packge provides easy publishing of interactive 3D visualizations of these.\nplotly is already useable for many applications, we can use techniques from rangl to put sf data into it, and we can use that to easily create exotic triangulated surfaces that are pretty inefficient in the simple features form:\nAlso check out Geotiff.js and timevis.\nHere are some rough examples with plotly.\nhttp://rpubs.com/cyclemumner/rangl-poly-topo-plotly\nhttp://rpubs.com/cyclemumner/raster-quads-to-triangles\nhttp://rpubs.com/cyclemumner/rangl-plotly\nI particularly want texture mapping to go with this kind of plotting, but apparently plotly cannot do that.\nhttps://twitter.com/mathinpython/status/818500905905561600"
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#the-limits-of-simple-features",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#the-limits-of-simple-features",
    "title": "R spatial in 2017",
    "section": "The limits of simple features",
    "text": "The limits of simple features\nSimple features can‚Äôt fully represent GPS and other track data, indexed meshes (like rgl mesh3d, segmented paths), or custom hierarchies like networks, nested objects like counties within states, or arc-node topology (like TopoJSON), and it can‚Äôt store aesthetics with primitives (like ggplot2/ggvis, rgl, plotly and others can). R can do all of these things, in many different ways and converting from and to sf is not too difficult.\nPlease don‚Äôt get the wrong idea though, sf is invaluable for developing more general tools that can work with these structures. Using the types in sf is very refreshing if you‚Äôve been frustrated trying to pick apart a Spatial object in the past.\nIn terms of going beyong simple features itself, GDAL is also going in this direction: http://lists.osgeo.org/pipermail/gdal-dev/2016-December/045675.html\nWe already have most of this capability in R, it‚Äôs just scattered all over the place. I‚Äôm interested to collate together the best workflows and see where this can go."
  },
  {
    "objectID": "posts/2017-01-10_r-spatial-2017/index.html#my-plans",
    "href": "posts/2017-01-10_r-spatial-2017/index.html#my-plans",
    "title": "R spatial in 2017",
    "section": "My plans",
    "text": "My plans\nI‚Äôm pretty comfortable now with sf and using it for what I want, I have converters to build the forms and workflows I need, and the support in mapview and leaflet and plotly provides more than enough to go with. I will work on making this as accessible and general as possible, and work on integrating it to replace my work on tracking data (the trip and SGAT packages), with 3D models (rbgm, quadmesh) and integrating it with htmlwidgets tools.\nI haven‚Äôt yet looked at curves, but I‚Äôm keen to see this capability in R both for sf and more generally, we could easily represent the forms made possible by TopoJSON (see ‚ÄúBostock flawed example‚Äù), there is curve support in grid.\nWe could provide smart geo-spatial finite element forms (triangulations, quads),\nI‚Äôm keen to see how ggvis and ggplot2 represent geometric types for objects that shared vertices, such as intervals and bar charts, and how we can put in indexed data structures (unlike what ggraph is doing, it builds a mesh from a group of coordinates, you can‚Äôt provide it with and index-mesh). I think we can build spatial structures that can store all of these things, so we could throw sf at ggplot2, and use the output as a kind of super-form that knows how to wrap it up into an interactive 4D plot, how to display its primitives etc. etc.\nGIS itself needs what we can already do in R, it‚Äôs not a target we are aspring to it‚Äôs the other way around."
  },
  {
    "objectID": "posts/2025-06-30-degenerate-zarr/different_polar_netcdfs.html",
    "href": "posts/2025-06-30-degenerate-zarr/different_polar_netcdfs.html",
    "title": "ncurl <- c(‚Äú/vsicurl/https://gws-access.jasmin.ac.uk/public/polarres/MetUM_PolarRES/Antarctic/daily/hfls_ANT-11_ERA5_evaluation_r1i1p1f1_BAS_MetUM_v1-r1_day_20000101_20001231.nc‚Äù,",
    "section": "",
    "text": "#‚Äî #title: ‚ÄúDegeneracy in array formats‚Äù #author: ‚ÄúMichael Sumner‚Äù #editor: source #date: ‚Äú2025-06-30‚Äù #categories: [news, code] #draft: true #‚Äî\nConsider these netcdf files.\n\nncurl &lt;- c(‚Äú/vsicurl/https://gws-access.jasmin.ac.uk/public/polarres/MetUM_PolarRES/Antarctic/daily/hfls_ANT-11_ERA5_evaluation_r1i1p1f1_BAS_MetUM_v1-r1_day_20000101_20001231.nc‚Äù,\n\n\n‚Äú/vsicurl/http://ftp.climato.be/fettweis/MARv3.13/PolarRES/Antarctic/MAR-MPI-ESM1/MARv3.13-ANT-MPI-1985.nc‚Äù)\n\n\n\n\n\nlibrary(terra)\n\n\n\n\n\n## equivalent to ‚Äú+proj=ob_tran +o_proj=longlat +o_lon_p=0 +o_lat_p=5 +lon_0=200 +datum=WGS84 +no_defs‚Äù\n\n\ncrs1 &lt;- ‚ÄòGEOGCRS[‚ÄúRotated_pole‚Äù,BASEGEOGCRS[‚ÄúWGS 84‚Äù,DATUM[‚ÄúWorld Geodetic System 1984‚Äù,ELLIPSOID[‚ÄúWGS 84‚Äù,6378137,298.257223563,LENGTHUNIT[‚Äúmetre‚Äù,1]]],PRIMEM[‚ÄúGreenwich‚Äù,0,ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433]]],DERIVINGCONVERSION[‚ÄúPole rotation (netCDF CF convention)‚Äù,METHOD[‚ÄúPole rotation (netCDF CF convention)‚Äù],PARAMETER[‚ÄúGrid north pole latitude (netCDF CF convention)‚Äù,5,ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433,ID[‚ÄúEPSG‚Äù,9122]]],PARAMETER[‚ÄúGrid north pole longitude (netCDF CF convention)‚Äù,20,ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433,ID[‚ÄúEPSG‚Äù,9122]]],PARAMETER[‚ÄúNorth pole grid longitude (netCDF CF convention)‚Äù,0,ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433,ID[‚ÄúEPSG‚Äù,9122]]]],CS[ellipsoidal,2],AXIS[‚Äúgeodetic latitude (Lat)‚Äù,north,ORDER[1],ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433,ID[‚ÄúEPSG‚Äù,9122]]],AXIS[‚Äúgeodetic longitude (Lon)‚Äù,east,ORDER[2],ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433,ID[‚ÄúEPSG‚Äù,9122]]]]‚Äô\n\n\ncrs2 &lt;- ‚ÄúWGS84‚Äù\n\n\nll1 &lt;- c(rast(ncurl[1], ‚Äúlongitude‚Äù),\n\n\nrast(ncurl[1], ‚Äúlatitude‚Äù)) * 1\n\n\nd1 &lt;- rast(ncurl[1], ‚Äúsurface_upward_latent_heat_flux‚Äù)\n\n\n\n\n\nll2 &lt;- c(rast(ncurl[2], ‚ÄúLON‚Äù), rast(ncurl[2], ‚ÄúLAT‚Äù)) * 1\n\n\npar(mfrow = c(2, 1))\n\n\nplot(values(ll1), xlim = c(-360, 220), pch = ‚Äú.‚Äù)\n\n\nplot(values(ll2), xlim = c(-360, 220), pch = ‚Äú.‚Äù)\n\n\n\n\n\nplot(project(values(ll1), from = ‚ÄúEPSG:4326‚Äù, to = crs1), pch = ‚Äú.‚Äù)\n\n\nplot(project(values(ll2), to = ‚ÄúEPSG:3031‚Äù, from = ‚ÄúEPSG:4326‚Äù), pch = ‚Äú.‚Äù)"
  },
  {
    "objectID": "posts/2024-12-05_idea_update/idea-update.html",
    "href": "posts/2024-12-05_idea_update/idea-update.html",
    "title": "IDEA - data and software",
    "section": "",
    "text": "raadtools, software to extract maps of ocean properties and values at points-in-time"
  },
  {
    "objectID": "posts/2024-12-05_idea_update/idea-update.html#section",
    "href": "posts/2024-12-05_idea_update/idea-update.html#section",
    "title": "IDEA - data and software",
    "section": "",
    "text": "raadtools, software to extract maps of ocean properties and values at points-in-time"
  },
  {
    "objectID": "posts/2024-12-05_idea_update/idea-update.html#raadtools-10-years-old-r-package",
    "href": "posts/2024-12-05_idea_update/idea-update.html#raadtools-10-years-old-r-package",
    "title": "IDEA - data and software",
    "section": "raadtools > 10 years old R package",
    "text": "raadtools &gt; 10 years old R package\n\n\n\n\n\n\n\nR function\nPurpose\n\n\n\n\nreadsst()\nglobal sea surface temperature\n\n\nreadice()\npolar sea ice concentrations\n\n\nreadghrsst()\nhigh resolution sea surface temperature\n\n\nread_adt/ugos/vgos_daily()\nglobal altimetry, sea height, surface currents\n\n\nread_chla_daily()\nglobal ocean colour\n\n\nreadtopo()\nglobal or local bathymetry\n\n\n‚Ä¶\n\n\n\n\nother functions we don‚Äôt have, yet ‚Ä¶"
  },
  {
    "objectID": "posts/2024-12-05_idea_update/idea-update.html#software-we-want",
    "href": "posts/2024-12-05_idea_update/idea-update.html#software-we-want",
    "title": "IDEA - data and software",
    "section": "software we want",
    "text": "software we want\n\n\n\nfeatures we want\nraadtools ü§î\n&lt;new tool&gt;\n\n\n\n\nusers don‚Äôt download files\n‚úÖ\n‚úÖ\n\n\ndata is up to date\n‚úÖ\n‚úÖ\n\n\nwe can add new data\n‚úÖ\n‚úÖ\n\n\nyou can add new data\n‚ùå\n‚úÖ\n\n\nuse outside AAD without Mike or Ben\n‚ùå\n‚úÖ\n\n\nuse outside of R\n‚ùå\n‚úÖ\n\n\nscale up on super computing\n‚ùå\n‚úÖ\n\n\nrobust to research/local outage\n‚ùå\n‚úÖ\n\n\navailable offline on Nuyina\n‚ùå\n??"
  },
  {
    "objectID": "posts/2024-12-05_idea_update/idea-update.html#python-support",
    "href": "posts/2024-12-05_idea_update/idea-update.html#python-support",
    "title": "IDEA - data and software",
    "section": "Python support",
    "text": "Python support\nAddress entire data cubes, with one line of code e.g.¬†daily data 1993 to November 2024\nimport xarray; &lt;some settings&gt;\n\nds = xarray.open_dataset('s3://vzarr/SEALEVEL_GLO_PHY_L4.parquet', &lt;more settings&gt;)\n&lt;xarray.Dataset&gt; Size: 574GB\nDimensions:    (time: 11538, latitude: 720, longitude: 1440)\nCoordinates:\n  * latitude   (latitude) float32 3kB -89.88 -89.62 -89.38 ... 89.38 89.62 89.88\n  * longitude  (longitude) float32 6kB -179.9 -179.6 -179.4 ... 179.6 179.9\n  * time       (time) datetime64[ns] 92kB 1993-01-01 1993-01-02 ... 2024-11-25\nData variables:\n    adt        (time, latitude, longitude) float64 96GB dask.array&lt;chunksize=(1, 50, 50), meta=np.ndarray&gt;\n    sla        (time, latitude, longitude) float64 96GB dask.array&lt;chunksize=(1, 50, 50), meta=np.ndarray&gt;\n    ugos       (time, latitude, longitude) float64 96GB dask.array&lt;chunksize=(1, 50, 50), meta=np.ndarray&gt;\n    ugosa      (time, latitude, longitude) float64 96GB dask.array&lt;chunksize=(1, 50, 50), meta=np.ndarray&gt;\n    vgos       (time, latitude, longitude) float64 96GB dask.array&lt;chunksize=(1, 50, 50), meta=np.ndarray&gt;\n    vgosa      (time, latitude, longitude) float64 96GB dask.array&lt;chunksize=(1, 50, 50), meta=np.ndarray&gt;\nAttributes: (12/44) ..."
  },
  {
    "objectID": "posts/2024-12-05_idea_update/idea-update.html#how-are-we-doing-this",
    "href": "posts/2024-12-05_idea_update/idea-update.html#how-are-we-doing-this",
    "title": "IDEA - data and software",
    "section": "How are we doing this",
    "text": "How are we doing this\n\nThe old and new tools reflect user-demand, tell us your ideas!\nModern tech: cloud-native and efficient public-available files\nData curation and cataloguing tools: {bowerbird}, STAC, VirtualiZarr\nExploring best-practice usage in Python xarray, odc, and in R terra, gdalraster, rsi\nContributing to software libraries GDAL.org, and community with AADC, SCAR, rOpenSci, Pangeo, Radiant Earth, Opendatacube, Digital Earth Antarctica"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "",
    "text": "I have been working on a better understanding of the GDAL multidimensional model and to do that really needs a closer look at the GDAL API itself.\nThis post demonstrates loading the GDAL API via its Python bindings into R. We connect to a modern ‚Äúcloud-ready‚Äù ZARR dataset, find out some details about its contents and then convert from its native multidimensional form to a more classic 2D raster model, then use that to create a map from Sentinel 2 imagery.\nWe don‚Äôt go very deep into any part, but just want to show a quick tour of some parts of GDAL that don‚Äôt get as much attention as deserved (IMO). I‚Äôm using a very recent version of GDAL, which might mean some code doesn‚Äôt work for you. If that‚Äôs the case please let me know and I can explore alternatives and identify when/how the newer features will be more available. There are some echoes here of an older post I made about GDAL in R: https://www.hypertidy.org/posts/2017-09-01_gdal-in-r/"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#the-gdal-api",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#the-gdal-api",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "",
    "text": "I have been working on a better understanding of the GDAL multidimensional model and to do that really needs a closer look at the GDAL API itself.\nThis post demonstrates loading the GDAL API via its Python bindings into R. We connect to a modern ‚Äúcloud-ready‚Äù ZARR dataset, find out some details about its contents and then convert from its native multidimensional form to a more classic 2D raster model, then use that to create a map from Sentinel 2 imagery.\nWe don‚Äôt go very deep into any part, but just want to show a quick tour of some parts of GDAL that don‚Äôt get as much attention as deserved (IMO). I‚Äôm using a very recent version of GDAL, which might mean some code doesn‚Äôt work for you. If that‚Äôs the case please let me know and I can explore alternatives and identify when/how the newer features will be more available. There are some echoes here of an older post I made about GDAL in R: https://www.hypertidy.org/posts/2017-09-01_gdal-in-r/"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#zarr-and-the-european-space-agency-esa",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#zarr-and-the-european-space-agency-esa",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "ZARR and the European Space Agency (ESA)",
    "text": "ZARR and the European Space Agency (ESA)\nThe ESA is moving Copernicus to ZARR, launching its Earth Observation Processing Framework (EOPF) data format (Zarr). ZARR is ‚Äúa community project to develop specifications and software for storage of large N-dimensional typed arrays‚Äù.\nA ZARR is a dataset consisting of trees of array chunks stored (usually) in object storage and indexed by fairly simple JSON metadata that describes how those chunks align together in one potentially very large array. The idea is that all the metadata lives upfront in instantly readable JSON, and changes made to the dataset (extending it each day as new data arrives) affects only the relevant chunks and the small parts of the JSON. This is different to a long list of NetCDFs that grows every day, where the metadata is self-contained for each file and there is no overarching abstraction for the entire file set.\nZARR is usually in object storage, and loaded by datacube software such as xarray. It‚Äôs not intended to be zipped into a huge file and downloaded or read, the real power lies in the entire dataset being lazy, and understood by software that needs just one data set description (url, or S3 path, etc)."
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#esa-sample-zarr-datasets",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#esa-sample-zarr-datasets",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "ESA sample Zarr datasets",
    "text": "ESA sample Zarr datasets\nThe ESA provide a set of example ZARRs that are available in zip files:\nhttps://eopf-public.s3.sbg.perf.cloud.ovh.net/product.html\nWe choose one that is described by this URL:\n\nurl &lt;- \"https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\""
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-urls-and-zip-files",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-urls-and-zip-files",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "GDAL urls and zip files",
    "text": "GDAL urls and zip files\nGDAL doesn‚Äôt force us to download data, but we need some syntax to leverage its remote capabilities in the simplest way. The Virtual File System (VSI) allows us to declare special sources like zip files /vsizip/ and urls /vsicurl/, which we can chain together. With ZARR we also need careful quoting of the description, and we declare the ZARR driver upfront.\n\n(dsn &lt;- sprintf('ZARR:\"/vsizip//vsicurl/%s\"', url))\n\n[1] \"ZARR:\\\"/vsizip//vsicurl/https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\\\"\""
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-and-multidimensional-datasets",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#gdal-and-multidimensional-datasets",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "GDAL and multidimensional datasets",
    "text": "GDAL and multidimensional datasets\nGDAL has a multidimensional mode for data sources that aren‚Äôt ‚Äúimagery‚Äù in the traditional sense. (If we open one of these datasets in ‚Äúclassic‚Äù mode we end up with a lot of bands on a 2D raster, or potentially many bands on many subdatasets within a more general container. Zarr is a container format, much like HDF5 and NetCDF).\nMultidimensional mode is avaible in the API via OpenEx() and declaring type OF_MULTIDIM_RASTER.\nTo actually load this python library we use {reticulate} py_require() which drives the awesome Python uv package manager.\n(For some reason the pypi name of the package is ‚Äúgdal‚Äù, but the actual module is obtained with ‚Äúosgeo.gdal‚Äù).\n\nreticulate::py_require(\"gdal\")\ngdal &lt;- reticulate::import(\"osgeo.gdal\")\ngdal$UseExceptions()\n\nsample(names(gdal), 40)  ## see that we have a huge coverage of the underlying API, 544 elements at time of writing\n\n [1] \"GCI_NIRBand\"                       \"GCI_CyanBand\"                     \n [3] \"GFU_RedMax\"                        \"GRT_COMPOSITE\"                    \n [5] \"GRT_AGGREGATION\"                   \"GRIORA_Gauss\"                     \n [7] \"GPI_RGB\"                           \"GFT_Integer\"                      \n [9] \"GFU_AlphaMin\"                      \"GCI_SAR_C_Band\"                   \n[11] \"GCI_OtherIRBand\"                   \"ApplyVerticalShiftGrid\"           \n[13] \"CPLE_NoWriteAccess\"                \"deprecation_warn\"                 \n[15] \"Rasterize\"                         \"GCI_SAR_K_Band\"                   \n[17] \"TermProgress_nocb\"                 \"GMF_ALL_VALID\"                    \n[19] \"DCAP_CREATECOPY\"                   \"GRA_Q1\"                           \n[21] \"config_option\"                     \"DCAP_FIELD_DOMAINS\"               \n[23] \"GDAL_GCP_Info_set\"                 \"wrapper_GDALVectorTranslateDestDS\"\n[25] \"ColorTable\"                        \"ContourGenerate\"                  \n[27] \"DCAP_COORDINATE_EPOCH\"             \"GDT_UInt16\"                       \n[29] \"GDsCDeleteRelationship\"            \"GCI_YCbCr_CbBand\"                 \n[31] \"IsLineOfSightVisible\"              \"BuildVRTInternalObjects\"          \n[33] \"DEMProcessing\"                     \"GDALDestroyDriverManager\"         \n[35] \"DCAP_RENAME_LAYERS\"                \"MultiDimInfoOptions\"              \n[37] \"CPLES_XML_BUT_QUOTES\"              \"DitherRGB2PCT\"                    \n[39] \"GDT_TypeCount\"                     \"GARIO_ERROR\"                      \n\n\nThe API elements chain in the usual way that works in python with ‚Äòobject.element.thing.etc‚Äô syntax uses R‚Äôs $ accessor.\n\ngdal$Dimension$GetIndexingVariable\n\n&lt;function Dimension.GetIndexingVariable at 0x7f08c9f61760&gt;\n signature: (self, *args) -&gt; 'GDALMDArrayHS *'"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#open-the-data",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#open-the-data",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "Open the data",
    "text": "Open the data\nIt‚Äôs not very exciting yet.\n\nds &lt;- gdal$OpenEx(dsn, gdal$OF_MULTIDIM_RASTER)\nds\n\n&lt;osgeo.gdal.Dataset; proxy of &lt;Swig Object of type 'GDALDatasetShadow *' at 0x7f08ca0ebcf0&gt; &gt;\n\n\nTo actually find out what‚Äôs in there we have to traverse a tree of potentially nested ‚Äúgroups‚Äù that organize actual datasets in a hierarchy.\nGet the root group and dive in, it‚Äôs very tediuous but shows some of what is there. There might be MDArrays in a group, or there might just be more groups.\n\nrg &lt;- ds$GetRootGroup()\nrg$GetMDArrayNames()\n\nlist()\n\nrg$GetGroupNames()\n\n[1] \"conditions\"   \"measurements\" \"quality\"     \n\ng1 &lt;- rg$OpenGroup(\"quality\")\ng1$GetMDArrayNames()\n\nlist()\n\ng1$GetGroupNames()\n\n[1] \"l1c_quicklook\" \"mask\"         \n\ng2 &lt;- g1$OpenGroup(\"l1c_quicklook\")\ng2$GetMDArrayNames()\n\nlist()\n\ng2$GetGroupNames()\n\n[1] \"r10m\"\n\ng3 &lt;- g2$OpenGroup(\"r10m\")\ng3$GetMDArrayNames()\n\n[1] \"band\" \"x\"    \"y\"    \"tci\" \n\ng3$GetGroupNames()\n\nlist()\n\n\nFinally we got to actual data, we recognize ‚Äòtci‚Äô as being the quicklook RGB of Sentinel 2.\nTo avoid tedium write a quick recursive function to find all the MDArray, at each level use GetFullName() which provides the cumulative path to where we are in the tree.\n\nget_all_mdnames &lt;- function(rootgroup) {\n  groups &lt;- rootgroup$GetGroupNames()\n  groupname &lt;- rootgroup$GetFullName()\n  amd &lt;- rootgroup$GetMDArrayNames()\n  md &lt;- sprintf(\"%s/%s\", groupname, amd)\n  md &lt;- c(md, unlist(lapply(groups, \\(.g) get_all_mdnames(rootgroup$OpenGroup(.g)))))\n  md\n}\n\nget_all_mdnames(ds$GetRootGroup())\n\n  [1] \"/conditions/geometry/angle\"                        \n  [2] \"/conditions/geometry/band\"                         \n  [3] \"/conditions/geometry/detector\"                     \n  [4] \"/conditions/geometry/x\"                            \n  [5] \"/conditions/geometry/y\"                            \n  [6] \"/conditions/geometry/mean_sun_angles\"              \n  [7] \"/conditions/geometry/mean_viewing_incidence_angles\"\n  [8] \"/conditions/geometry/sun_angles\"                   \n  [9] \"/conditions/geometry/viewing_incidence_angles\"     \n [10] \"/conditions/mask/detector_footprint/r10m/x\"        \n [11] \"/conditions/mask/detector_footprint/r10m/y\"        \n [12] \"/conditions/mask/detector_footprint/r10m/b02\"      \n [13] \"/conditions/mask/detector_footprint/r10m/b03\"      \n [14] \"/conditions/mask/detector_footprint/r10m/b04\"      \n [15] \"/conditions/mask/detector_footprint/r10m/b08\"      \n [16] \"/conditions/mask/detector_footprint/r20m/x\"        \n [17] \"/conditions/mask/detector_footprint/r20m/y\"        \n [18] \"/conditions/mask/detector_footprint/r20m/b05\"      \n [19] \"/conditions/mask/detector_footprint/r20m/b06\"      \n [20] \"/conditions/mask/detector_footprint/r20m/b07\"      \n [21] \"/conditions/mask/detector_footprint/r20m/b11\"      \n [22] \"/conditions/mask/detector_footprint/r20m/b12\"      \n [23] \"/conditions/mask/detector_footprint/r20m/b8a\"      \n [24] \"/conditions/mask/detector_footprint/r60m/x\"        \n [25] \"/conditions/mask/detector_footprint/r60m/y\"        \n [26] \"/conditions/mask/detector_footprint/r60m/b01\"      \n [27] \"/conditions/mask/detector_footprint/r60m/b09\"      \n [28] \"/conditions/mask/detector_footprint/r60m/b10\"      \n [29] \"/conditions/mask/l1c_classification/r60m/x\"        \n [30] \"/conditions/mask/l1c_classification/r60m/y\"        \n [31] \"/conditions/mask/l1c_classification/r60m/b00\"      \n [32] \"/conditions/meteorology/cams/latitude\"             \n [33] \"/conditions/meteorology/cams/longitude\"            \n [34] \"/conditions/meteorology/cams/aod1240\"              \n [35] \"/conditions/meteorology/cams/aod469\"               \n [36] \"/conditions/meteorology/cams/aod550\"               \n [37] \"/conditions/meteorology/cams/aod670\"               \n [38] \"/conditions/meteorology/cams/aod865\"               \n [39] \"/conditions/meteorology/cams/bcaod550\"             \n [40] \"/conditions/meteorology/cams/duaod550\"             \n [41] \"/conditions/meteorology/cams/isobaricInhPa\"        \n [42] \"/conditions/meteorology/cams/number\"               \n [43] \"/conditions/meteorology/cams/omaod550\"             \n [44] \"/conditions/meteorology/cams/ssaod550\"             \n [45] \"/conditions/meteorology/cams/step\"                 \n [46] \"/conditions/meteorology/cams/suaod550\"             \n [47] \"/conditions/meteorology/cams/surface\"              \n [48] \"/conditions/meteorology/cams/time\"                 \n [49] \"/conditions/meteorology/cams/valid_time\"           \n [50] \"/conditions/meteorology/cams/z\"                    \n [51] \"/conditions/meteorology/ecmwf/latitude\"            \n [52] \"/conditions/meteorology/ecmwf/longitude\"           \n [53] \"/conditions/meteorology/ecmwf/isobaricInhPa\"       \n [54] \"/conditions/meteorology/ecmwf/msl\"                 \n [55] \"/conditions/meteorology/ecmwf/number\"              \n [56] \"/conditions/meteorology/ecmwf/r\"                   \n [57] \"/conditions/meteorology/ecmwf/step\"                \n [58] \"/conditions/meteorology/ecmwf/surface\"             \n [59] \"/conditions/meteorology/ecmwf/tco3\"                \n [60] \"/conditions/meteorology/ecmwf/tcwv\"                \n [61] \"/conditions/meteorology/ecmwf/time\"                \n [62] \"/conditions/meteorology/ecmwf/u10\"                 \n [63] \"/conditions/meteorology/ecmwf/v10\"                 \n [64] \"/conditions/meteorology/ecmwf/valid_time\"          \n [65] \"/measurements/reflectance/r10m/x\"                  \n [66] \"/measurements/reflectance/r10m/y\"                  \n [67] \"/measurements/reflectance/r10m/b02\"                \n [68] \"/measurements/reflectance/r10m/b03\"                \n [69] \"/measurements/reflectance/r10m/b04\"                \n [70] \"/measurements/reflectance/r10m/b08\"                \n [71] \"/measurements/reflectance/r20m/x\"                  \n [72] \"/measurements/reflectance/r20m/y\"                  \n [73] \"/measurements/reflectance/r20m/b05\"                \n [74] \"/measurements/reflectance/r20m/b06\"                \n [75] \"/measurements/reflectance/r20m/b07\"                \n [76] \"/measurements/reflectance/r20m/b11\"                \n [77] \"/measurements/reflectance/r20m/b12\"                \n [78] \"/measurements/reflectance/r20m/b8a\"                \n [79] \"/measurements/reflectance/r60m/x\"                  \n [80] \"/measurements/reflectance/r60m/y\"                  \n [81] \"/measurements/reflectance/r60m/b01\"                \n [82] \"/measurements/reflectance/r60m/b09\"                \n [83] \"/measurements/reflectance/r60m/b10\"                \n [84] \"/quality/l1c_quicklook/r10m/band\"                  \n [85] \"/quality/l1c_quicklook/r10m/x\"                     \n [86] \"/quality/l1c_quicklook/r10m/y\"                     \n [87] \"/quality/l1c_quicklook/r10m/tci\"                   \n [88] \"/quality/mask/r10m/x\"                              \n [89] \"/quality/mask/r10m/y\"                              \n [90] \"/quality/mask/r10m/b02\"                            \n [91] \"/quality/mask/r10m/b03\"                            \n [92] \"/quality/mask/r10m/b04\"                            \n [93] \"/quality/mask/r10m/b08\"                            \n [94] \"/quality/mask/r20m/x\"                              \n [95] \"/quality/mask/r20m/y\"                              \n [96] \"/quality/mask/r20m/b05\"                            \n [97] \"/quality/mask/r20m/b06\"                            \n [98] \"/quality/mask/r20m/b07\"                            \n [99] \"/quality/mask/r20m/b11\"                            \n[100] \"/quality/mask/r20m/b12\"                            \n[101] \"/quality/mask/r20m/b8a\"                            \n[102] \"/quality/mask/r60m/x\"                              \n[103] \"/quality/mask/r60m/y\"                              \n[104] \"/quality/mask/r60m/b01\"                            \n[105] \"/quality/mask/r60m/b09\"                            \n[106] \"/quality/mask/r60m/b10\"                            \n\n\nHappily, we see our target MDArray name in there /quality/l1c_quicklook/r10m/tci."
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#actual-data",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#actual-data",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "Actual data",
    "text": "Actual data\nFinally let‚Äôs get some data out. We can obtain the MDArray now by full name and find out some properties.\n\nreticulate::py_require(\"gdal\")\ngdal &lt;- reticulate::import(\"osgeo.gdal\")\ngdal$UseExceptions()\n\ndsn &lt;- \"ZARR:\\\"/vsizip//vsicurl/https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\\\"\"\n\nds &lt;- gdal$OpenEx(dsn, gdal$OF_MULTIDIM_RASTER)\nrg &lt;- ds$GetRootGroup()\nmdname &lt;- \"/quality/l1c_quicklook/r10m/tci\"\nmd &lt;- rg$OpenMDArrayFromFullname(mdname)\nmd$GetDimensionCount()\n\n[1] 3\n\n\nTraverse the dimensions to get their sizes and names.\n\nvapply(md$GetDimensions(), \\(.d) .d$GetSize(), 0L)\n\n[1]     3 10980 10980\n\nvapply(md$GetDimensions(), \\(.d) .d$GetName(), \"\")\n\n[1] \"band\" \"y\"    \"x\"   \n\n\nExplore some metadata attributes.\n\nmnames &lt;- vapply(md$GetAttributes(), \\(.a) .a$GetName(), \"\")\n\n(meta &lt;- setNames(lapply(md$GetAttributes(), \\(.a) unlist(.a$Read())), mnames))\n\n$long_name\n[1] \"TCI: True Color Image\"\n\n$`proj:bbox`\n[1]  300000 4490220  409800 4600020\n\n$`proj:epsg`\n[1] 32636\n\n$`proj:shape`\n[1] 10980 10980\n\n$`proj:transform`\n[1]      10       0  300000       0     -10 4600020       0       0       1\n\n$`proj:wkt2`\n[1] \"PROJCS[\\\"WGS 84 / UTM zone 36N\\\",GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",33],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32636\\\"]]\"\n\n\nWe see that the CRS information is in there, but sadly while the geotransform of the data is maintained when we convert to classic raster the CRS does not make the journey (the geotransform is just the image bbox intermingled with its resolution in a mathematical abstraction used in matrix manipulation).\nA multidim raster can be converted to classic form, either in whole or after applying a $GetView() operation that acts like numpy ‚Äò[:]‚Äô array subsetting.\nWhen converting to classic raster we specify the x, then y dimensions of the dataset, which from multdim convention are in reverse order. (Note that dimension 0 is the ‚Äú3rd‚Äù dimension in normal thinking, here that dimension is ‚Äúband‚Äù or a dimension for each of red, green, blue in the quicklook image).\n\ncc &lt;- md$AsClassicDataset(2L, 1L)\ntr &lt;- unlist(cc$GetGeoTransform())\ndm &lt;- c(cc$RasterXSize, cc$RasterYSize)\ncc$GetSpatialRef() ## empty, so we retrieve from the attributes\ncrs &lt;- cc$GetMetadata()[[\"proj:wkt2\"]]\n\nNow, I used reproj_extent to convert the dataset‚Äôs bbox to one in longlat, but I won‚Äôt share that here, we‚Äôll just use the result so our map is a little more familiar. The source data xy bbox is xmin: 300000 ymin: 4490220  xmax: 409800 ymax:4600020, and we take small section of that which is this in longitude latitude:\n\n# xmin,xmax,ymin,ymax converted below to bbox \nex &lt;- c(31.689, 31.774, 40.665, 40.724)\n\nTo warp the imagery to this region we first need to set the CRS properly on the dataset, so translate to a temporary VRT and use that dataset for the next step.\n\ndsvrt &lt;- gdal$Translate(tempfile(fileext = \".vrt\", tmpdir = \"/vsimem\"), cc, options = c(\"-a_srs\", crs))\ntf &lt;- tf &lt;- \"/vsimem/result.tif\"\nww &lt;- gdal$Warp(tf, dsvrt,  dstSRS = \"EPSG:4326\", outputBounds = ex[c(1, 3, 2, 4)])\nww$Close()\n\n[1] 0\n\n\nFinally we can read the image, plot it, obtain some contextual data and be assured that our map is correct.\n\nlibrary(gdalraster)\ndata &lt;- read_ds(new(GDALRaster, tf))\n\n\nlibrary(osmdata)\nx &lt;- opq(ex[c(1, 3, 2, 4)]) |&gt; add_osm_feature(key = \"highway\") |&gt; osmdata_sf()\n\nlibrary(sf)\nplot_raster(data)\nplot(x$osm_lines[0], add = TRUE, col = \"hotpink\")"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#summary",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#summary",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "Summary",
    "text": "Summary\nWe had a look at GDAL multidimensional API, converting a 3D dataset to classic raster, augmenting the missing CRS information on a virtual copy and then warping an image to a familiar map context.\nThere is ongoing work to bring the full GDAL API to R in {gdalraster}, and in-development version of gdalraster to add the GDALMultiDimRaster class and helpers: https://github.com/mdsumner/gdalraster/tree/multidimnew.\nPlease get in touch if any of this is of interest!"
  },
  {
    "objectID": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#late-bonus-section-bluelink-ocean-model",
    "href": "posts/2025-03-12-r-py-multidim/r-py-multidim.html#late-bonus-section-bluelink-ocean-model",
    "title": "GDAL multidim and cloud-ready ZARR",
    "section": "Late Bonus Section: Bluelink ocean model",
    "text": "Late Bonus Section: Bluelink ocean model\nThis is something I want to use VRT to encapsulate as one whole dataset, here just a test on one file (there are 174 of these ocean_temp files, up to June 2024 at time of writing).\nNote that we are using ‚Äò/fileServer/‚Äô from Thredds, not ‚Äò/dodsC/‚Äô. GDAL uses userfaultd as a trick to read NetCDF remotely.\nfrom osgeo import gdal\ndsn = \"/vsicurl/https://thredds.nci.org.au/thredds/fileServer/gb6/BRAN/BRAN2023/daily/ocean_temp_2010_01.nc\"\nds = gdal.OpenEx(dsn, gdal.OF_MULTIDIM_RASTER)\nrg = ds.GetRootGroup()\nrg.GetMDArrayNames()\n# ['xt_ocean', 'yt_ocean', 'st_ocean', 'Time', 'nv', 'st_edges_ocean', 'average_T1', 'average_T2', 'average_DT', 'Time_bnds', 'temp']\n\ntemp = rg.OpenMDArrayFromFullname(\"//temp\")\n[d.GetName() for d in temp.GetDimensions()]\n#['Time', 'st_ocean', 'yt_ocean', 'xt_ocean']\n[d.GetSize() for d in temp.GetDimensions()]\n#[31, 51, 1500, 3600]\nI don‚Äôt know why xarray can seemingly read netcdf from S3, but not from normal url? Maybe just something fsspec I need to understand?\nI also noticed that if the file is local the array names at root level are like this:\n['//xt_ocean', '//yt_ocean', '//st_ocean', '//Time', '//nv', '//st_edges_ocean', '//average_T1', '//average_T2', '//average_DT', '//Time_bnds', '//temp']\n\n\ngdalraster::gdal_version()\n\n[1] \"GDAL 3.11.0dev-dd6009a0eb, released 2018/99/99\"\n[2] \"3110000\"                                       \n[3] \"20189999\"                                      \n[4] \"3.11.0dev-dd6009a0eb\"                          \n\ndevtools::session_info()\n\n‚îÄ Session info ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n setting  value\n version  R version 4.4.2 (2024-10-31)\n os       Ubuntu 20.04.6 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_AU.UTF-8\n ctype    en_AU.UTF-8\n tz       Australia/Hobart\n date     2025-03-12\n pandoc   3.2 @ /usr/lib/rstudio-server/bin/quarto/bin/tools/x86_64/ (via rmarkdown)\n\n‚îÄ Packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n package     * version     date (UTC) lib source\n bit           4.5.0.1     2024-12-03 [2] CRAN (R 4.4.2)\n bit64         4.6.0-1     2025-01-16 [2] CRAN (R 4.4.2)\n cachem        1.1.0       2024-05-16 [2] CRAN (R 4.4.1)\n class         7.3-23      2025-01-01 [4] CRAN (R 4.4.2)\n classInt      0.4-11      2025-01-08 [2] CRAN (R 4.4.2)\n cli           3.6.4       2025-02-13 [2] CRAN (R 4.4.2)\n codetools     0.2-20      2024-03-31 [4] CRAN (R 4.4.1)\n curl          6.2.1       2025-02-19 [2] CRAN (R 4.4.2)\n DBI           1.2.3       2024-06-02 [2] CRAN (R 4.4.1)\n devtools      2.4.5       2022-10-11 [2] CRAN (R 4.4.1)\n digest        0.6.37      2024-08-19 [2] CRAN (R 4.4.1)\n e1071         1.7-16      2024-09-16 [2] CRAN (R 4.4.1)\n ellipsis      0.3.2       2021-04-29 [2] CRAN (R 4.4.1)\n evaluate      1.0.3       2025-01-10 [2] CRAN (R 4.4.2)\n fastmap       1.2.0       2024-05-15 [2] CRAN (R 4.4.1)\n fs            1.6.5.9000  2024-12-18 [2] Github (r-lib/fs@8d40528)\n gdalraster  * 1.12.0.9250 2025-03-10 [1] local\n generics      0.1.3       2022-07-05 [2] CRAN (R 4.4.1)\n glue          1.8.0       2024-09-30 [2] CRAN (R 4.4.1)\n here          1.0.1       2020-12-13 [2] CRAN (R 4.4.1)\n htmltools     0.5.8.1     2024-04-04 [2] CRAN (R 4.4.1)\n htmlwidgets   1.6.4       2023-12-06 [2] CRAN (R 4.4.1)\n httpuv        1.6.15      2024-03-26 [2] CRAN (R 4.4.1)\n httr2         1.1.0       2025-01-18 [2] CRAN (R 4.4.2)\n jsonlite      1.9.0       2025-02-19 [2] CRAN (R 4.4.2)\n KernSmooth    2.23-26     2025-01-01 [4] CRAN (R 4.4.2)\n knitr         1.49        2024-11-08 [2] CRAN (R 4.4.2)\n later         1.3.2       2023-12-06 [2] CRAN (R 4.4.1)\n lattice       0.22-6      2024-03-20 [4] CRAN (R 4.4.1)\n lifecycle     1.0.4       2023-11-07 [2] CRAN (R 4.4.1)\n lubridate     1.9.4       2024-12-08 [2] CRAN (R 4.4.2)\n magrittr      2.0.3       2022-03-30 [2] CRAN (R 4.4.1)\n Matrix        1.7-0       2024-04-26 [2] CRAN (R 4.4.1)\n memoise       2.0.1       2021-11-26 [2] CRAN (R 4.4.1)\n mime          0.12        2021-09-28 [2] CRAN (R 4.4.1)\n miniUI        0.1.1.1     2018-05-18 [2] CRAN (R 4.4.1)\n nanoarrow     0.6.0       2024-10-13 [2] CRAN (R 4.4.2)\n osmdata     * 0.2.5       2023-08-14 [2] CRAN (R 4.4.2)\n pkgbuild      1.4.4       2024-03-17 [2] CRAN (R 4.4.1)\n pkgload       1.4.0       2024-06-28 [2] CRAN (R 4.4.1)\n png           0.1-8       2022-11-29 [2] CRAN (R 4.4.1)\n profvis       0.4.0       2024-09-20 [2] CRAN (R 4.4.1)\n promises      1.3.0       2024-04-05 [2] CRAN (R 4.4.1)\n proxy         0.4-27      2022-06-09 [2] CRAN (R 4.4.1)\n purrr         1.0.4.9000  2025-02-19 [2] Github (tidyverse/purrr@9c8beb4)\n R6            2.6.1       2025-02-15 [2] CRAN (R 4.4.2)\n rappdirs      0.3.3       2021-01-31 [2] CRAN (R 4.4.1)\n Rcpp          1.0.14      2025-01-12 [2] CRAN (R 4.4.2)\n remotes       2.5.0       2024-03-17 [2] CRAN (R 4.4.1)\n reticulate  * 1.41.0      2025-02-24 [2] CRAN (R 4.4.2)\n rlang         1.1.5       2025-01-17 [2] CRAN (R 4.4.2)\n rmarkdown     2.29        2024-11-04 [2] CRAN (R 4.4.2)\n rprojroot     2.0.4       2023-11-05 [2] CRAN (R 4.4.1)\n rstudioapi    0.16.0      2024-03-24 [2] CRAN (R 4.4.1)\n sessioninfo   1.2.2       2021-12-06 [2] CRAN (R 4.4.1)\n sf          * 1.0-19      2024-11-05 [2] CRAN (R 4.4.2)\n shiny         1.9.1       2024-08-01 [2] CRAN (R 4.4.1)\n timechange    0.3.0       2024-01-18 [2] CRAN (R 4.4.1)\n units         0.8-5       2023-11-28 [2] CRAN (R 4.4.1)\n urlchecker    1.0.1       2021-11-30 [2] CRAN (R 4.4.1)\n usethis       3.0.0       2024-07-29 [2] CRAN (R 4.4.1)\n vctrs         0.6.5       2023-12-01 [2] CRAN (R 4.4.1)\n withr         3.0.2       2024-10-28 [2] CRAN (R 4.4.1)\n wk            0.9.4       2024-10-11 [2] CRAN (R 4.4.1)\n xfun          0.50        2025-01-07 [2] CRAN (R 4.4.2)\n xml2          1.3.6       2023-12-04 [2] CRAN (R 4.4.1)\n xtable        1.8-4       2019-04-21 [2] CRAN (R 4.4.1)\n yaml          2.3.10      2024-07-26 [2] CRAN (R 4.4.1)\n\n [1] /perm_storage/home/mdsumner/R/x86_64-pc-linux-gnu-library/4.4\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n‚îÄ Python configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n python:         /perm_storage/home/mdsumner/.cache/R/reticulate/uv/cache/archive-v0/twFzciVwGCsaiQXG6_cWf/bin/python3\n libpython:      /perm_storage/home/mdsumner/.local/share/uv/python/cpython-3.11.11-linux-x86_64-gnu/lib/libpython3.11.so\n pythonhome:     /perm_storage/home/mdsumner/.cache/R/reticulate/uv/cache/archive-v0/twFzciVwGCsaiQXG6_cWf:/perm_storage/home/mdsumner/.cache/R/reticulate/uv/cache/archive-v0/twFzciVwGCsaiQXG6_cWf\n virtualenv:     /perm_storage/home/mdsumner/.cache/R/reticulate/uv/cache/archive-v0/twFzciVwGCsaiQXG6_cWf/bin/activate_this.py\n version:        3.11.11 (main, Feb 12 2025, 14:51:05) [Clang 19.1.6 ]\n numpy:          /perm_storage/home/mdsumner/.cache/R/reticulate/uv/cache/archive-v0/twFzciVwGCsaiQXG6_cWf/lib/python3.11/site-packages/numpy\n numpy_version:  2.2.3\n osgeo:          /perm_storage/home/mdsumner/.cache/R/reticulate/uv/cache/archive-v0/twFzciVwGCsaiQXG6_cWf/lib/python3.11/site-packages/osgeo\n \n NOTE: Python version was forced by py_require()\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\nreticulate::py_require()\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Python requirements ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n\n‚îÄ‚îÄ Current requirements ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\n Python:   [No Python version specified. Will default to '3.11.11']\n Packages: numpy, gdal\n\n\n‚îÄ‚îÄ R package requests ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\nR package  Python packages                           Python version      \nreticulate numpy"
  },
  {
    "objectID": "posts/2025-09-04-broken-netcdf/index.html",
    "href": "posts/2025-09-04-broken-netcdf/index.html",
    "title": "Coordinates broken in NetCDF",
    "section": "",
    "text": "There‚Äôs a NetCDF file at this URL:\n\"https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\nIt‚Äôs fairly straightforward:\nnetcdf CS2WFA_25km_201007 {\ndimensions:\n        y = 332 ;\n        x = 316 ;\n        time = 1 ;\nvariables:\n        float time(time) ;\n                time:long_name = \"time\" ;\n                time:units = \"months since 2000-01-01\" ;\n                time:calendar = \"360_day\" ;\n        double lat(y, x) ;\n                lat:long_name = \"latitude\" ;\n                lat:units = \"degrees_north\" ;\n        double lon(y, x) ;\n                lon:long_name = \"longitude\" ;\n                lon:units = \"degrees_east\" ;\n        double snow_freeboard(time, y, x) ;\n                snow_freeboard:least_significant_digit = 4LL ;\n                snow_freeboard:units = \"m\" ;\n                snow_freeboard:standard_name = \"snow_freeboard\" ;\n                snow_freeboard:description = \"Mean snow (total) freeboard in grid cell\" ;\n        double ice_freeboard(time, y, x) ;\n                ice_freeboard:least_significant_digit = 4LL ;\n                ice_freeboard:units = \"m\" ;\n                ice_freeboard:standard_name = \"ice_freeboard\" ;\n                ice_freeboard:description = \"Mean ice freeboard in grid cell\" ;\n        double snow_depth(time, y, x) ;\n                snow_depth:least_significant_digit = 4LL ;\n                snow_depth:units = \"m\" ;\n                snow_depth:standard_name = \"snow_depth\" ;\n                snow_depth:description = \"Mean snow depth on sea ice in grid cell\" ;\n        double sea_ice_concentration(time, y, x) ;\n                sea_ice_concentration:least_significant_digit = 4LL ;\n                sea_ice_concentration:units = \"1\" ;\n                sea_ice_concentration:standard_name = \"sea_ice_area_fraction\" ;\n                sea_ice_concentration:description = \"Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\" ;\n\n// global attributes:\n                :title = \"Antarctic sea ice physical properties obtained from CryoSat-2 using the CS2WFA algorithm\" ;\n                :institution = \"NASA GSFC Cryospheric Sciences Laboratory and University of Maryland-College Park\" ;\n                :history = \"File created on November 15, 2022, 12:09:06\" ;\n\ngroup: sea_ice_thickness {\n  variables:\n        double sea_ice_thickness(time, y, x) ;\n                sea_ice_thickness:least_significant_digit = 4LL ;\n                sea_ice_thickness:units = \"m\" ;\n                sea_ice_thickness:standard_name = \"sea_ice_thickness\" ;\n                sea_ice_thickness:description = \"Mean sea ice thickness in grid cell\" ;\n        double sea_ice_thickness_70percent_threshold(time, y, x) ;\n                sea_ice_thickness_70percent_threshold:least_significant_digit = 4LL ;\n                sea_ice_thickness_70percent_threshold:units = \"m\" ;\n                sea_ice_thickness_70percent_threshold:standard_name = \"sea_ice_thickness_70percent_threshold\" ;\n                sea_ice_thickness_70percent_threshold:description = \"Mean sea ice thickness in grid cell found using the 70% power threshold retracking algorithm\" ;\n        double sea_ice_thickness_zero_icefreeboard(time, y, x) ;\n                sea_ice_thickness_zero_icefreeboard:least_significant_digit = 4LL ;\n                sea_ice_thickness_zero_icefreeboard:units = \"m\" ;\n                sea_ice_thickness_zero_icefreeboard:standard_name = \"sea_ice_thickness_zero_icefreeboard\" ;\n                sea_ice_thickness_zero_icefreeboard:description = \"Mean sea ice thickness in grid cell found using the zero-ice-freeboard assumption\" ;\n        double sea_ice_thickness_uncertainty(time, y, x) ;\n                sea_ice_thickness_uncertainty:least_significant_digit = 4LL ;\n                sea_ice_thickness_uncertainty:units = \"m\" ;\n                sea_ice_thickness_uncertainty:standard_name = \"sea_ice_thickness_uncertainty\" ;\n                sea_ice_thickness_uncertainty:description = \"Mean systematic sea ice thickness uncertainty in grid cell\" ;\n  } // group sea_ice_thickness\n\ngroup: density {\n  variables:\n        double ice_density(time, y, x) ;\n                ice_density:least_significant_digit = 4LL ;\n                ice_density:units = \"kg m-3\" ;\n                ice_density:standard_name = \"seasonal_sea_ice_density\" ;\n                ice_density:description = \"Seasonal value of sea ice density\" ;\n        double snow_density(time, y, x) ;\n                snow_density:least_significant_digit = 4LL ;\n                snow_density:units = \"kg m-3\" ;\n                snow_density:standard_name = \"seasonal_snow_density\" ;\n                snow_density:description = \"Seasonal value of snow density\" ;\n        double seawater_density(time, y, x) ;\n                seawater_density:least_significant_digit = 4LL ;\n                seawater_density:units = \"kg m-3\" ;\n                seawater_density:standard_name = \"seasonal_seawater_density\" ;\n                seawater_density:description = \"Seasonal value of seawater density\" ;\n  } // group density\n}\nThere‚Äôs a root group with two variables defined in time,y,x and another two groups with further variables on that same grid.\nEach data array is 316x332x1 and we can tell that every lon,lat pair is stored explicitly. This fits a convention in NetCDF where time is ‚Äúunlimited‚Äù and we‚Äôre only looking at a subset of an overall time series, that could well be continually generated day to day still now.\nLet‚Äôs investigate the coordinates. We‚Äôll use GDAL via a commonly used wrapper in R, its ‚Äòvsicurl‚Äô protocol to stream from the internet, and declare the driver explicitly (lest we get the less sophisticated HDF5 interpretation).\n\n#dsn &lt;- \"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\ndsn &lt;- \"NETCDF:../CS2WFA_25km_201007.nc\"\nlibrary(terra)\n\nterra 1.8.62\n\nlon &lt;- rast(dsn, \"lon\")\n\nError in R_nc4_open: No such file or directory\n\n\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n\nlat &lt;- rast(dsn, \"lat\")\n\nError in R_nc4_open: No such file or directory\n\n\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n\nplot(c(lon, lat))\n\n\n\n\n\n\n\n\nWe get a message from terra about ‚Äúcells not equally spaced‚Äù, which means that when reading an array the geospatial context in GDAL didn‚Äôt find anything specifying a compact representation of coordinates, but lon and lat are the coordinates as data, so we can safely ignore this message. (There‚Äôs another message about ncdf4, but ignore that too it‚Äôs terra try(ing) stuff. )\nWe won‚Äôt pay attention to ‚Äútime‚Äù, because our file only has one time step. We‚Äôre interested in these lon,lat coordinates. What does the data itself look like? Again we choose one of the 3D variables (with degenerate 3rd dimension ‚Äòtime‚Äô) by name.\n\nice &lt;- rast(dsn, \"sea_ice_concentration\")\n\nError in R_nc4_open: No such file or directory\n\n\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n\nplot(ice)\n\n\n\n\n\n\n\n\nThat should look familiar, though notice that we don‚Äôt have any spatial information it‚Äôs just a matrix in its own index coordinates, 0,316 for x and 0,332 for y.\nLet‚Äôs plot the coordinates. Now we can see our data in a much more spatial-ish context.\n\nxyz &lt;- values(c(lon, lat, ice))\nplot(xyz[,1:2], pch = \".\", col = palr::d_pal(xyz[,3]), asp = 2)\nmaps::map(\"world2\", add = TRUE)\n\n\n\n\n\n\n\n\nWe now don‚Äôt have a nice gridded dataset, it‚Äôs points in longitude latitude. What can we do to plot it in that nice polar aspect with proper spatial referencing?\nLet‚Äôs have a look at this dataset from a GDAL perspective. Now we use the API package gdalraster which gives a lot more control over GDAL itself. I‚Äôm going to skip over interrogating the syntax for a particular array, like we did with terra and ‚Äòsea_ice_concentration‚Äô above, I construct the subdataset syntax to open.\n\n\"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\n\n[1] \"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\n\nsds &lt;- sprintf(\"%s:sea_ice_concentration\", dsn)\nlibrary(gdalraster)\n\nGDAL 3.12.0dev-4e2b27da8f (released 2025-08-26), GEOS 3.12.1, PROJ 9.3.1\n\n\n\nAttaching package: 'gdalraster'\n\n\nThe following object is masked from 'package:terra':\n\n    rasterize\n\nds &lt;- new(GDALRaster, sds)\nds$info()\n\nDriver: netCDF/Network Common Data Format\nFiles: ../CS2WFA_25km_201007.nc\nSize is 316, 332\nMetadata:\n  NC_GLOBAL#history=File created on November 15, 2022, 12:09:06\n  NC_GLOBAL#institution=NASA GSFC Cryospheric Sciences Laboratory and University of Maryland-College Park\n  NC_GLOBAL#title=Antarctic sea ice physical properties obtained from CryoSat-2 using the CS2WFA algorithm\n  NETCDF_DIM_EXTRA={time}\n  NETCDF_DIM_time_DEF={1,5}\n  NETCDF_DIM_time_VALUES=126\n  sea_ice_concentration#description=Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\n  sea_ice_concentration#least_significant_digit=4\n  sea_ice_concentration#standard_name=sea_ice_area_fraction\n  sea_ice_concentration#units=1\n  time#calendar=360_day\n  time#long_name=time\n  time#units=months since 2000-01-01\nGeolocation:\n  SRS=GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n  X_DATASET=NETCDF:\"../CS2WFA_25km_201007.nc\":lon\n  X_BAND=1\n  Y_DATASET=NETCDF:\"../CS2WFA_25km_201007.nc\":lat\n  Y_BAND=1\n  PIXEL_OFFSET=0\n  PIXEL_STEP=1\n  LINE_OFFSET=0\n  LINE_STEP=1\n  GEOREFERENCING_CONVENTION=PIXEL_CENTER\nCorner Coordinates:\nUpper Left  (    0.0,    0.0)\nLower Left  (    0.0,  332.0)\nUpper Right (  316.0,    0.0)\nLower Right (  316.0,  332.0)\nCenter      (  158.0,  166.0)\nBand 1 Block=316x332 Type=Float64, ColorInterp=Undefined\n  NoData Value=9.969209968386869e+36\n  Unit Type: 1\n  Metadata:\n    NETCDF_VARNAME=sea_ice_concentration\n    least_significant_digit=4\n    units=1\n    standard_name=sea_ice_area_fraction\n    description=Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\n    NETCDF_DIM_time=126\n\n\nThe interesting part of that output is under ‚ÄúGeolocation:‚Äù. We can see that while GDAL doesn‚Äôt have spatial referencing for this array, it does seem to know that‚Äôs it‚Äôs possible because of the X_DATASET and Y_DATASET. These can be used by the GDAL warper API (warp means ‚Äúreprojection‚Äù or ‚Äúreshaping‚Äù for an image) in order to resolve to a spatial dataset. So let‚Äôs warp.\nWe don‚Äôt have to specifying the geolocation arrays, we saw that GDAL already knows this. We‚Äôll write conveniently to a temporary virtual ‚Äúfile‚Äù so we can avoid more cleanup.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\")\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(icegrid &lt;- rast(tf))\n\n\n\n\n\n\n\nicegrid\n\nclass       : SpatRaster \nsize        : 127, 902, 1  (nrow, ncol, nlyr)\nresolution  : 0.398722, 0.3987662  (x, y)\nextent      : 0.164645, 359.8119, -89.80441, -39.1611  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb795a721b7d4e.tif \nname        : fileb795a721b7d4e \n\n\nWe indeed now have a spatial grid, a raster. But perhaps we don‚Äôt like the 0,360 convention. We can set the target extent, GDAL had to figure one out from the input geolocation arrays, and it will usually do a good job but it‚Äôs really our responsibility to specify what we want for reproducibility in later workflows.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\", \n                 cl_arg = c(\"-te\", -180, -90, 180, -39, \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(icegrid &lt;- rast(tf))\n\n\n\n\n\n\n\nicegrid\n\nclass       : SpatRaster \nsize        : 194, 1371, 1  (nrow, ncol, nlyr)\nresolution  : 0.2625821, 0.2628866  (x, y)\nextent      : -180, 180, -90, -39  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb795a9d85964.tif \nname        : fileb795a9d85964 \n\n\nAnother thing that is also our responsibility is the dimensions of the grid and the resolution, obviously this an extent are all interlinked so we augment our bounding box / extent setting with a nice clean resolution.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\", \n                 cl_arg = c(\"-te\", -180, -90, 180, -39, \"-tr\", 0.25, 0.25,\n                            \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(icegrid &lt;- rast(tf))\n\n\n\n\n\n\n\nicegrid\n\nclass       : SpatRaster \nsize        : 204, 1440, 1  (nrow, ncol, nlyr)\nresolution  : 0.25, 0.25  (x, y)\nextent      : -180, 180, -90, -39  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb795a3ee65e99.tif \nname        : fileb795a3ee65e99 \n\n\nThat is all well and nice, and we‚Äôve quietly demonstrated some of the key powers of GDAL:\n\nvirtualization\nwarping with heuristics to a CRS\nwarping with a grid specification, and using geolocation arrays to guide the grid-resolving process\nsetting grid specification with any of crs, extent(bbox), resolution, dimension, and allowing GDAL to internally wrap from 0,360 context to -180,180\n\nBut, we still don‚Äôt have that nice polar aspect we saw from the raw array above. So we change CRS. ‚ÄòEPSG:3412‚Äô is a Polar Stereographic map projection on the south pole, commonly used for standard sea ice products. As a grid this has nice properties, that don‚Äôt require edge-wrap for a matrix model, it‚Äôs true scale at approximately where the coastline of Antarctica is, and it preserves shape (this means not all cells are exactly the same size, but they‚Äôre close enough for where the sea ice is).\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(polargrid &lt;- rast(tf))\n\n\n\n\n\n\n\npolargrid\n\nclass       : SpatRaster \nsize        : 348, 332, 1  (nrow, ncol, nlyr)\nresolution  : 24999.84, 24999.84  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb795a4e985f4e.tif \nname        : fileb795a4e985f4e \n\n\nTo make sure let‚Äôs get some spatial data to plot with this.\n\nv &lt;- vect(\"/vsizip//vsicurl/https://github.com/wmgeolab/geoBoundaries/raw/main/releaseData/CGAZ/geoBoundariesCGAZ_ADM0.zip\", \n     query = \"SELECT shapeGroup FROM geoBoundariesCGAZ_ADM0 WHERE shapeGroup IN ('ATA')\")\nv &lt;- crop(v, ext(-180, 180, -84, 0)) ## small hack to remove the pole seam\nv &lt;- project(v, \"EPSG:3412\")\nplot(polargrid)\nplot(v, add = TRUE)\n\n\n\n\n\n\n\n\nLooks good! We‚Äôve plotted the original data in the correct polar aspect.\nBut, the data aren‚Äôt exactly the same, we‚Äôve added pixels in the heuristic used by GDAL to determine the grid specification from the extent and resolution of the geolocation array longitude and latitudes.\n\nice\n\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 1, 1  (x, y)\nextent      : 0, 316, 0, 332  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource      : CS2WFA_25km_201007.nc:sea_ice_concentration \nvarname     : sea_ice_concentration (sea_ice_area_fraction) \nname        : sea_ice_concentration \nunit        :                     1 \n\npolargrid\n\nclass       : SpatRaster \nsize        : 348, 332, 1  (nrow, ncol, nlyr)\nresolution  : 24999.84, 24999.84  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb795a4e985f4e.tif \nname        : fileb795a4e985f4e \n\n\nSo, let‚Äôs try to use the same grid.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-ts\", 316, 332,\n                           \n                  \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\npolargrid &lt;- rast(tf)\n\npolargrid\n\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 26265.66, 26204.65  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb795a221237f7.tif \nname        : fileb795a221237f7 \n\n\nWe can‚Äôt do that without giving them the same extent, but we still don‚Äôt know what that is for the original data. So let‚Äôs calculate it.\n\nxy &lt;- project(values(c(lon, lat)), to = \"EPSG:3412\", from = \"EPSG:4326\")\nrange(xy[,2])\n\n[1] -3937527  4337533"
  },
  {
    "objectID": "posts/2025-09-04-broken-netcdf/index.html#a-netcdf-file",
    "href": "posts/2025-09-04-broken-netcdf/index.html#a-netcdf-file",
    "title": "Coordinates broken in NetCDF",
    "section": "",
    "text": "There‚Äôs a NetCDF file at this URL:\n\"https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\nIt‚Äôs fairly straightforward:\nnetcdf CS2WFA_25km_201007 {\ndimensions:\n        y = 332 ;\n        x = 316 ;\n        time = 1 ;\nvariables:\n        float time(time) ;\n                time:long_name = \"time\" ;\n                time:units = \"months since 2000-01-01\" ;\n                time:calendar = \"360_day\" ;\n        double lat(y, x) ;\n                lat:long_name = \"latitude\" ;\n                lat:units = \"degrees_north\" ;\n        double lon(y, x) ;\n                lon:long_name = \"longitude\" ;\n                lon:units = \"degrees_east\" ;\n        double snow_freeboard(time, y, x) ;\n                snow_freeboard:least_significant_digit = 4LL ;\n                snow_freeboard:units = \"m\" ;\n                snow_freeboard:standard_name = \"snow_freeboard\" ;\n                snow_freeboard:description = \"Mean snow (total) freeboard in grid cell\" ;\n        double ice_freeboard(time, y, x) ;\n                ice_freeboard:least_significant_digit = 4LL ;\n                ice_freeboard:units = \"m\" ;\n                ice_freeboard:standard_name = \"ice_freeboard\" ;\n                ice_freeboard:description = \"Mean ice freeboard in grid cell\" ;\n        double snow_depth(time, y, x) ;\n                snow_depth:least_significant_digit = 4LL ;\n                snow_depth:units = \"m\" ;\n                snow_depth:standard_name = \"snow_depth\" ;\n                snow_depth:description = \"Mean snow depth on sea ice in grid cell\" ;\n        double sea_ice_concentration(time, y, x) ;\n                sea_ice_concentration:least_significant_digit = 4LL ;\n                sea_ice_concentration:units = \"1\" ;\n                sea_ice_concentration:standard_name = \"sea_ice_area_fraction\" ;\n                sea_ice_concentration:description = \"Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\" ;\n\n// global attributes:\n                :title = \"Antarctic sea ice physical properties obtained from CryoSat-2 using the CS2WFA algorithm\" ;\n                :institution = \"NASA GSFC Cryospheric Sciences Laboratory and University of Maryland-College Park\" ;\n                :history = \"File created on November 15, 2022, 12:09:06\" ;\n\ngroup: sea_ice_thickness {\n  variables:\n        double sea_ice_thickness(time, y, x) ;\n                sea_ice_thickness:least_significant_digit = 4LL ;\n                sea_ice_thickness:units = \"m\" ;\n                sea_ice_thickness:standard_name = \"sea_ice_thickness\" ;\n                sea_ice_thickness:description = \"Mean sea ice thickness in grid cell\" ;\n        double sea_ice_thickness_70percent_threshold(time, y, x) ;\n                sea_ice_thickness_70percent_threshold:least_significant_digit = 4LL ;\n                sea_ice_thickness_70percent_threshold:units = \"m\" ;\n                sea_ice_thickness_70percent_threshold:standard_name = \"sea_ice_thickness_70percent_threshold\" ;\n                sea_ice_thickness_70percent_threshold:description = \"Mean sea ice thickness in grid cell found using the 70% power threshold retracking algorithm\" ;\n        double sea_ice_thickness_zero_icefreeboard(time, y, x) ;\n                sea_ice_thickness_zero_icefreeboard:least_significant_digit = 4LL ;\n                sea_ice_thickness_zero_icefreeboard:units = \"m\" ;\n                sea_ice_thickness_zero_icefreeboard:standard_name = \"sea_ice_thickness_zero_icefreeboard\" ;\n                sea_ice_thickness_zero_icefreeboard:description = \"Mean sea ice thickness in grid cell found using the zero-ice-freeboard assumption\" ;\n        double sea_ice_thickness_uncertainty(time, y, x) ;\n                sea_ice_thickness_uncertainty:least_significant_digit = 4LL ;\n                sea_ice_thickness_uncertainty:units = \"m\" ;\n                sea_ice_thickness_uncertainty:standard_name = \"sea_ice_thickness_uncertainty\" ;\n                sea_ice_thickness_uncertainty:description = \"Mean systematic sea ice thickness uncertainty in grid cell\" ;\n  } // group sea_ice_thickness\n\ngroup: density {\n  variables:\n        double ice_density(time, y, x) ;\n                ice_density:least_significant_digit = 4LL ;\n                ice_density:units = \"kg m-3\" ;\n                ice_density:standard_name = \"seasonal_sea_ice_density\" ;\n                ice_density:description = \"Seasonal value of sea ice density\" ;\n        double snow_density(time, y, x) ;\n                snow_density:least_significant_digit = 4LL ;\n                snow_density:units = \"kg m-3\" ;\n                snow_density:standard_name = \"seasonal_snow_density\" ;\n                snow_density:description = \"Seasonal value of snow density\" ;\n        double seawater_density(time, y, x) ;\n                seawater_density:least_significant_digit = 4LL ;\n                seawater_density:units = \"kg m-3\" ;\n                seawater_density:standard_name = \"seasonal_seawater_density\" ;\n                seawater_density:description = \"Seasonal value of seawater density\" ;\n  } // group density\n}\nThere‚Äôs a root group with two variables defined in time,y,x and another two groups with further variables on that same grid.\nEach data array is 316x332x1 and we can tell that every lon,lat pair is stored explicitly. This fits a convention in NetCDF where time is ‚Äúunlimited‚Äù and we‚Äôre only looking at a subset of an overall time series, that could well be continually generated day to day still now.\nLet‚Äôs investigate the coordinates. We‚Äôll use GDAL via a commonly used wrapper in R, its ‚Äòvsicurl‚Äô protocol to stream from the internet, and declare the driver explicitly (lest we get the less sophisticated HDF5 interpretation).\n\n#dsn &lt;- \"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\ndsn &lt;- \"NETCDF:../CS2WFA_25km_201007.nc\"\nlibrary(terra)\n\nterra 1.8.62\n\nlon &lt;- rast(dsn, \"lon\")\n\nError in R_nc4_open: No such file or directory\n\n\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n\nlat &lt;- rast(dsn, \"lat\")\n\nError in R_nc4_open: No such file or directory\n\n\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n\nplot(c(lon, lat))\n\n\n\n\n\n\n\n\nWe get a message from terra about ‚Äúcells not equally spaced‚Äù, which means that when reading an array the geospatial context in GDAL didn‚Äôt find anything specifying a compact representation of coordinates, but lon and lat are the coordinates as data, so we can safely ignore this message. (There‚Äôs another message about ncdf4, but ignore that too it‚Äôs terra try(ing) stuff. )\nWe won‚Äôt pay attention to ‚Äútime‚Äù, because our file only has one time step. We‚Äôre interested in these lon,lat coordinates. What does the data itself look like? Again we choose one of the 3D variables (with degenerate 3rd dimension ‚Äòtime‚Äô) by name.\n\nice &lt;- rast(dsn, \"sea_ice_concentration\")\n\nError in R_nc4_open: No such file or directory\n\n\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n\nplot(ice)\n\n\n\n\n\n\n\n\nThat should look familiar, though notice that we don‚Äôt have any spatial information it‚Äôs just a matrix in its own index coordinates, 0,316 for x and 0,332 for y.\nLet‚Äôs plot the coordinates. Now we can see our data in a much more spatial-ish context.\n\nxyz &lt;- values(c(lon, lat, ice))\nplot(xyz[,1:2], pch = \".\", col = palr::d_pal(xyz[,3]), asp = 2)\nmaps::map(\"world2\", add = TRUE)\n\n\n\n\n\n\n\n\nWe now don‚Äôt have a nice gridded dataset, it‚Äôs points in longitude latitude. What can we do to plot it in that nice polar aspect with proper spatial referencing?\nLet‚Äôs have a look at this dataset from a GDAL perspective. Now we use the API package gdalraster which gives a lot more control over GDAL itself. I‚Äôm going to skip over interrogating the syntax for a particular array, like we did with terra and ‚Äòsea_ice_concentration‚Äô above, I construct the subdataset syntax to open.\n\n\"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\n\n[1] \"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\n\nsds &lt;- sprintf(\"%s:sea_ice_concentration\", dsn)\nlibrary(gdalraster)\n\nGDAL 3.12.0dev-4e2b27da8f (released 2025-08-26), GEOS 3.12.1, PROJ 9.3.1\n\n\n\nAttaching package: 'gdalraster'\n\n\nThe following object is masked from 'package:terra':\n\n    rasterize\n\nds &lt;- new(GDALRaster, sds)\nds$info()\n\nDriver: netCDF/Network Common Data Format\nFiles: ../CS2WFA_25km_201007.nc\nSize is 316, 332\nMetadata:\n  NC_GLOBAL#history=File created on November 15, 2022, 12:09:06\n  NC_GLOBAL#institution=NASA GSFC Cryospheric Sciences Laboratory and University of Maryland-College Park\n  NC_GLOBAL#title=Antarctic sea ice physical properties obtained from CryoSat-2 using the CS2WFA algorithm\n  NETCDF_DIM_EXTRA={time}\n  NETCDF_DIM_time_DEF={1,5}\n  NETCDF_DIM_time_VALUES=126\n  sea_ice_concentration#description=Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\n  sea_ice_concentration#least_significant_digit=4\n  sea_ice_concentration#standard_name=sea_ice_area_fraction\n  sea_ice_concentration#units=1\n  time#calendar=360_day\n  time#long_name=time\n  time#units=months since 2000-01-01\nGeolocation:\n  SRS=GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n  X_DATASET=NETCDF:\"../CS2WFA_25km_201007.nc\":lon\n  X_BAND=1\n  Y_DATASET=NETCDF:\"../CS2WFA_25km_201007.nc\":lat\n  Y_BAND=1\n  PIXEL_OFFSET=0\n  PIXEL_STEP=1\n  LINE_OFFSET=0\n  LINE_STEP=1\n  GEOREFERENCING_CONVENTION=PIXEL_CENTER\nCorner Coordinates:\nUpper Left  (    0.0,    0.0)\nLower Left  (    0.0,  332.0)\nUpper Right (  316.0,    0.0)\nLower Right (  316.0,  332.0)\nCenter      (  158.0,  166.0)\nBand 1 Block=316x332 Type=Float64, ColorInterp=Undefined\n  NoData Value=9.969209968386869e+36\n  Unit Type: 1\n  Metadata:\n    NETCDF_VARNAME=sea_ice_concentration\n    least_significant_digit=4\n    units=1\n    standard_name=sea_ice_area_fraction\n    description=Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\n    NETCDF_DIM_time=126\n\n\nThe interesting part of that output is under ‚ÄúGeolocation:‚Äù. We can see that while GDAL doesn‚Äôt have spatial referencing for this array, it does seem to know that‚Äôs it‚Äôs possible because of the X_DATASET and Y_DATASET. These can be used by the GDAL warper API (warp means ‚Äúreprojection‚Äù or ‚Äúreshaping‚Äù for an image) in order to resolve to a spatial dataset. So let‚Äôs warp.\nWe don‚Äôt have to specifying the geolocation arrays, we saw that GDAL already knows this. We‚Äôll write conveniently to a temporary virtual ‚Äúfile‚Äù so we can avoid more cleanup.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\")\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(icegrid &lt;- rast(tf))\n\n\n\n\n\n\n\nicegrid\n\nclass       : SpatRaster \nsize        : 127, 902, 1  (nrow, ncol, nlyr)\nresolution  : 0.398722, 0.3987662  (x, y)\nextent      : 0.164645, 359.8119, -89.80441, -39.1611  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb795a721b7d4e.tif \nname        : fileb795a721b7d4e \n\n\nWe indeed now have a spatial grid, a raster. But perhaps we don‚Äôt like the 0,360 convention. We can set the target extent, GDAL had to figure one out from the input geolocation arrays, and it will usually do a good job but it‚Äôs really our responsibility to specify what we want for reproducibility in later workflows.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\", \n                 cl_arg = c(\"-te\", -180, -90, 180, -39, \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(icegrid &lt;- rast(tf))\n\n\n\n\n\n\n\nicegrid\n\nclass       : SpatRaster \nsize        : 194, 1371, 1  (nrow, ncol, nlyr)\nresolution  : 0.2625821, 0.2628866  (x, y)\nextent      : -180, 180, -90, -39  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb795a9d85964.tif \nname        : fileb795a9d85964 \n\n\nAnother thing that is also our responsibility is the dimensions of the grid and the resolution, obviously this an extent are all interlinked so we augment our bounding box / extent setting with a nice clean resolution.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\", \n                 cl_arg = c(\"-te\", -180, -90, 180, -39, \"-tr\", 0.25, 0.25,\n                            \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(icegrid &lt;- rast(tf))\n\n\n\n\n\n\n\nicegrid\n\nclass       : SpatRaster \nsize        : 204, 1440, 1  (nrow, ncol, nlyr)\nresolution  : 0.25, 0.25  (x, y)\nextent      : -180, 180, -90, -39  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb795a3ee65e99.tif \nname        : fileb795a3ee65e99 \n\n\nThat is all well and nice, and we‚Äôve quietly demonstrated some of the key powers of GDAL:\n\nvirtualization\nwarping with heuristics to a CRS\nwarping with a grid specification, and using geolocation arrays to guide the grid-resolving process\nsetting grid specification with any of crs, extent(bbox), resolution, dimension, and allowing GDAL to internally wrap from 0,360 context to -180,180\n\nBut, we still don‚Äôt have that nice polar aspect we saw from the raw array above. So we change CRS. ‚ÄòEPSG:3412‚Äô is a Polar Stereographic map projection on the south pole, commonly used for standard sea ice products. As a grid this has nice properties, that don‚Äôt require edge-wrap for a matrix model, it‚Äôs true scale at approximately where the coastline of Antarctica is, and it preserves shape (this means not all cells are exactly the same size, but they‚Äôre close enough for where the sea ice is).\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\nplot(polargrid &lt;- rast(tf))\n\n\n\n\n\n\n\npolargrid\n\nclass       : SpatRaster \nsize        : 348, 332, 1  (nrow, ncol, nlyr)\nresolution  : 24999.84, 24999.84  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb795a4e985f4e.tif \nname        : fileb795a4e985f4e \n\n\nTo make sure let‚Äôs get some spatial data to plot with this.\n\nv &lt;- vect(\"/vsizip//vsicurl/https://github.com/wmgeolab/geoBoundaries/raw/main/releaseData/CGAZ/geoBoundariesCGAZ_ADM0.zip\", \n     query = \"SELECT shapeGroup FROM geoBoundariesCGAZ_ADM0 WHERE shapeGroup IN ('ATA')\")\nv &lt;- crop(v, ext(-180, 180, -84, 0)) ## small hack to remove the pole seam\nv &lt;- project(v, \"EPSG:3412\")\nplot(polargrid)\nplot(v, add = TRUE)\n\n\n\n\n\n\n\n\nLooks good! We‚Äôve plotted the original data in the correct polar aspect.\nBut, the data aren‚Äôt exactly the same, we‚Äôve added pixels in the heuristic used by GDAL to determine the grid specification from the extent and resolution of the geolocation array longitude and latitudes.\n\nice\n\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 1, 1  (x, y)\nextent      : 0, 316, 0, 332  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource      : CS2WFA_25km_201007.nc:sea_ice_concentration \nvarname     : sea_ice_concentration (sea_ice_area_fraction) \nname        : sea_ice_concentration \nunit        :                     1 \n\npolargrid\n\nclass       : SpatRaster \nsize        : 348, 332, 1  (nrow, ncol, nlyr)\nresolution  : 24999.84, 24999.84  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb795a4e985f4e.tif \nname        : fileb795a4e985f4e \n\n\nSo, let‚Äôs try to use the same grid.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-ts\", 316, 332,\n                           \n                  \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\npolargrid &lt;- rast(tf)\n\npolargrid\n\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 26265.66, 26204.65  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb795a221237f7.tif \nname        : fileb795a221237f7 \n\n\nWe can‚Äôt do that without giving them the same extent, but we still don‚Äôt know what that is for the original data. So let‚Äôs calculate it.\n\nxy &lt;- project(values(c(lon, lat)), to = \"EPSG:3412\", from = \"EPSG:4326\")\nrange(xy[,2])\n\n[1] -3937527  4337533"
  },
  {
    "objectID": "posts/2025-09-04-broken-netcdf/index.html#throw-all-that-away-ignore-everything-above.",
    "href": "posts/2025-09-04-broken-netcdf/index.html#throw-all-that-away-ignore-everything-above.",
    "title": "Coordinates broken in NetCDF",
    "section": "Throw all that away, ignore everything above.",
    "text": "Throw all that away, ignore everything above.\nThe problem here is that we can‚Äôt reconstruct the actual grid in the file, we have to treat it as points in geolocation arrays, and infer something about the grid. Here‚Äôs the answer:\n\nex &lt;- c(xmin = -3950000,  xmax = 3950000, ymin  = -3950000, ymax = 4350000)\ndiff(ex)[c(1, 3)] / c(316, 332)  ## look familiar?\n\n xmax  ymax \n25000 25000 \n\n\n\nset_ext &lt;- function(x, ex) {terra::ext(x) &lt;- ex; x}\n\nplot(set_ext(ice, ext(ex)))\nplot(v, add = T)\n\n\n\n\n\n\n\nplot(polargrid); plot(v, add = TRUE)\n\n\n\n\n\n\n\n\nNow finally, we get exactly the same answer.\n\ngdalraster::warp(sds,  tf &lt;- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-ts\", 316, 332, \"-te\", ex[1], ex[3], ex[2], ex[4],\n                           \n                  \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n\n0...10...20...30...40...50...60...70...80...90...100 - done.\n\npolargrid &lt;- rast(tf)\n\npolargrid\n\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 25000, 25000  (x, y)\nextent      : -3950000, 3950000, -3950000, 4350000  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb795a36bbb6c2.tif \nname        : fileb795a36bbb6c2 \n\npolargrid - set_ext(ice, ext(ex))\n\nWarning: [-] CRS do not match\n\n\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 25000, 25000  (x, y)\nextent      : -3950000, 3950000, -3950000, 4350000  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource(s)   : memory\nvarname     : fileb795a36bbb6c2 \nname        : fileb795a36bbb6c2 \nmin value   :                 0 \nmax value   :                 0 \n\n# class       : SpatRaster \n# size        : 332, 316, 1  (nrow, ncol, nlyr)\n# resolution  : 25000, 25000  (x, y)\n# extent      : -3950000, 3950000, -3950000, 4350000  (xmin, xmax, ymin, ymax)\n# coord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \n# source(s)   : memory\n# varname     : fileb328ade0cec2 \n# name        : fileb328ade0cec2 \n# min value   :                0 \n# max value   :                0 \n\nBut how did we do that? We plucked some magic numbers out of the air. We can‚Äôt obtain those four numbers from the lon lat arrays, we can‚Äôt find them in the file, they aren‚Äôt in the metadata or the website. We just know, because NSIDC sea ice products are standard on a 3412 grid at 25km resolution.\nThis is an entropy problem."
  }
]