---
title: "Coordinates broken in  NetCDF"
author: "Michael Sumner"
format: html
date: "2025-09-04"
editor: source
categories: [news, code]
draft: false
---

## A NetCDF file

There's a NetCDF file at this URL: 

```
"https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1"
```

It's fairly straightforward: 

```
netcdf CS2WFA_25km_201007 {
dimensions:
        y = 332 ;
        x = 316 ;
        time = 1 ;
variables:
        float time(time) ;
                time:long_name = "time" ;
                time:units = "months since 2000-01-01" ;
                time:calendar = "360_day" ;
        double lat(y, x) ;
                lat:long_name = "latitude" ;
                lat:units = "degrees_north" ;
        double lon(y, x) ;
                lon:long_name = "longitude" ;
                lon:units = "degrees_east" ;
        double snow_freeboard(time, y, x) ;
                snow_freeboard:least_significant_digit = 4LL ;
                snow_freeboard:units = "m" ;
                snow_freeboard:standard_name = "snow_freeboard" ;
                snow_freeboard:description = "Mean snow (total) freeboard in grid cell" ;
        double ice_freeboard(time, y, x) ;
                ice_freeboard:least_significant_digit = 4LL ;
                ice_freeboard:units = "m" ;
                ice_freeboard:standard_name = "ice_freeboard" ;
                ice_freeboard:description = "Mean ice freeboard in grid cell" ;
        double snow_depth(time, y, x) ;
                snow_depth:least_significant_digit = 4LL ;
                snow_depth:units = "m" ;
                snow_depth:standard_name = "snow_depth" ;
                snow_depth:description = "Mean snow depth on sea ice in grid cell" ;
        double sea_ice_concentration(time, y, x) ;
                sea_ice_concentration:least_significant_digit = 4LL ;
                sea_ice_concentration:units = "1" ;
                sea_ice_concentration:standard_name = "sea_ice_area_fraction" ;
                sea_ice_concentration:description = "Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)" ;

// global attributes:
                :title = "Antarctic sea ice physical properties obtained from CryoSat-2 using the CS2WFA algorithm" ;
                :institution = "NASA GSFC Cryospheric Sciences Laboratory and University of Maryland-College Park" ;
                :history = "File created on November 15, 2022, 12:09:06" ;

group: sea_ice_thickness {
  variables:
        double sea_ice_thickness(time, y, x) ;
                sea_ice_thickness:least_significant_digit = 4LL ;
                sea_ice_thickness:units = "m" ;
                sea_ice_thickness:standard_name = "sea_ice_thickness" ;
                sea_ice_thickness:description = "Mean sea ice thickness in grid cell" ;
        double sea_ice_thickness_70percent_threshold(time, y, x) ;
                sea_ice_thickness_70percent_threshold:least_significant_digit = 4LL ;
                sea_ice_thickness_70percent_threshold:units = "m" ;
                sea_ice_thickness_70percent_threshold:standard_name = "sea_ice_thickness_70percent_threshold" ;
                sea_ice_thickness_70percent_threshold:description = "Mean sea ice thickness in grid cell found using the 70% power threshold retracking algorithm" ;
        double sea_ice_thickness_zero_icefreeboard(time, y, x) ;
                sea_ice_thickness_zero_icefreeboard:least_significant_digit = 4LL ;
                sea_ice_thickness_zero_icefreeboard:units = "m" ;
                sea_ice_thickness_zero_icefreeboard:standard_name = "sea_ice_thickness_zero_icefreeboard" ;
                sea_ice_thickness_zero_icefreeboard:description = "Mean sea ice thickness in grid cell found using the zero-ice-freeboard assumption" ;
        double sea_ice_thickness_uncertainty(time, y, x) ;
                sea_ice_thickness_uncertainty:least_significant_digit = 4LL ;
                sea_ice_thickness_uncertainty:units = "m" ;
                sea_ice_thickness_uncertainty:standard_name = "sea_ice_thickness_uncertainty" ;
                sea_ice_thickness_uncertainty:description = "Mean systematic sea ice thickness uncertainty in grid cell" ;
  } // group sea_ice_thickness

group: density {
  variables:
        double ice_density(time, y, x) ;
                ice_density:least_significant_digit = 4LL ;
                ice_density:units = "kg m-3" ;
                ice_density:standard_name = "seasonal_sea_ice_density" ;
                ice_density:description = "Seasonal value of sea ice density" ;
        double snow_density(time, y, x) ;
                snow_density:least_significant_digit = 4LL ;
                snow_density:units = "kg m-3" ;
                snow_density:standard_name = "seasonal_snow_density" ;
                snow_density:description = "Seasonal value of snow density" ;
        double seawater_density(time, y, x) ;
                seawater_density:least_significant_digit = 4LL ;
                seawater_density:units = "kg m-3" ;
                seawater_density:standard_name = "seasonal_seawater_density" ;
                seawater_density:description = "Seasonal value of seawater density" ;
  } // group density
}
```

There's a root group with two variables defined in time,y,x and another two groups with further variables on that same grid. 

Each data array is 316x332x1 and we can tell that every lon,lat pair is stored explicitly. This fits a convention in NetCDF where time is "unlimited" and we're only looking
at a subset of an overall time series, that could well be continually generated day to day still now. 


Let's investigate the coordinates. We'll use GDAL via a commonly used wrapper in R, its 'vsicurl' protocol to stream from the internet, and declare the driver explicitly (lest we get the less sophisticated HDF5 interpretation). 

```{r coords}
#dsn <- "NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1"
dsn <- "NETCDF:../CS2WFA_25km_201007.nc"
library(terra)
lon <- rast(dsn, "lon")
lat <- rast(dsn, "lat")
plot(c(lon, lat))


```

We get a message from terra about "cells not equally spaced", which means that when reading an array the geospatial context in GDAL didn't find anything specifying a compact representation of coordinates, but lon and lat *are the coordinates* **as data**, so we can safely ignore this message. 
(There's another message about ncdf4, but ignore that too it's terra try(ing) stuff. )

We won't pay attention to "time", because our file only has one time step. We're interested in these lon,lat coordinates. What does the data itself look like? Again we choose one of the 3D variables (with degenerate 3rd dimension 'time') by name. 

```{r data}
ice <- rast(dsn, "sea_ice_concentration")
plot(ice)
```

That should look familiar, though notice that we don't have any spatial information it's just a matrix in its own index coordinates, 0,316 for x and 0,332 for y. 

Let's plot the coordinates. Now we can see our data in a much more spatial-ish context. 

```{r plot}
xyz <- values(c(lon, lat, ice))
plot(xyz[,1:2], pch = ".", col = palr::d_pal(xyz[,3]), asp = 2)
maps::map("world2", add = TRUE)
```
 
 
We now don't have a nice gridded dataset, it's points in longitude latitude. What can we do to plot it in that nice polar aspect with proper spatial referencing? 

Let's have a look at this dataset from a GDAL perspective. Now we use the API package `gdalraster` which gives a lot more control over GDAL itself.  I'm going to skip over interrogating the syntax for a particular array, like we did with terra and 'sea_ice_concentration' above, I construct the subdataset syntax to open. 

```{r gdalraster}
"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1"
sds <- sprintf("%s:sea_ice_concentration", dsn)
library(gdalraster)
ds <- new(GDALRaster, sds)
ds$info()
```

The interesting part of that output is under "Geolocation:". We can see that while GDAL doesn't have spatial referencing for this array, it does seem to know that's it's possible because of the X_DATASET and Y_DATASET. These can be used by the GDAL warper API (warp means "reprojection" or "reshaping" for an image) in order to resolve to a spatial dataset. So let's warp. 

We don't have to specifying the geolocation arrays, we saw that GDAL already knows this. We'll write conveniently to a temporary virtual "file" so we can avoid more cleanup. 

```{r warp}
gdalraster::warp(sds,  tf <- tempfile(fileext = ".tif", tmpdir = "/vsimem"), t_srs = "EPSG:4326")

plot(icegrid <- rast(tf))
icegrid
```

We indeed now have a spatial grid, a raster. But perhaps we don't like the 0,360 convention. We can set the target extent, GDAL had to figure one out from the input geolocation arrays, and it will usually do a good job but it's really our responsibility to specify what we want for reproducibility in later workflows. 

```{r extent}
gdalraster::warp(sds,  tf <- tempfile(fileext = ".tif", tmpdir = "/vsimem"), t_srs = "EPSG:4326", 
                 cl_arg = c("-te", -180, -90, 180, -39, "-to", "GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES"))

plot(icegrid <- rast(tf))
icegrid
```

Another thing that is also our responsibility is the dimensions of the grid and the resolution, obviously this an extent are all interlinked so we augment our bounding box / extent setting with a nice clean resolution. 

```{r extent2}
gdalraster::warp(sds,  tf <- tempfile(fileext = ".tif", tmpdir = "/vsimem"), t_srs = "EPSG:4326", 
                 cl_arg = c("-te", -180, -90, 180, -39, "-tr", 0.25, 0.25,
                            "-to", "GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES"))

plot(icegrid <- rast(tf))
icegrid
```

That is all well and nice, and we've quietly demonstrated some of the key powers of GDAL: 

- virtualization
- warping with heuristics to a CRS
- warping with a grid specification, and using geolocation arrays to guide the grid-resolving process
- setting grid specification with any of crs, extent(bbox), resolution, dimension, and allowing GDAL to internally wrap from 0,360 context to -180,180


But, we still don't have that nice polar aspect we saw from the raw array above. So we change CRS. 'EPSG:3412' is a Polar Stereographic map projection on the south pole, commonly used for standard sea ice products. As a grid this has nice properties, that don't require edge-wrap for a matrix model, it's true scale at approximately where the coastline of Antarctica is, and it preserves shape (this means not all cells are exactly the same size, but they're close enough for where the sea ice is). 

```{r polargrid}
gdalraster::warp(sds,  tf <- tempfile(fileext = ".tif", tmpdir = "/vsimem"), t_srs = "EPSG:3412", 
                cl_arg = c("-to", "GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES"))

plot(polargrid <- rast(tf))
polargrid
```

To make sure let's get some spatial data to plot with this. 

```{r spatial}
v <- vect("/vsizip//vsicurl/https://github.com/wmgeolab/geoBoundaries/raw/main/releaseData/CGAZ/geoBoundariesCGAZ_ADM0.zip", 
     query = "SELECT shapeGroup FROM geoBoundariesCGAZ_ADM0 WHERE shapeGroup IN ('ATA')")
v <- crop(v, ext(-180, 180, -84, 0)) ## small hack to remove the pole seam
v <- project(v, "EPSG:3412")
plot(polargrid)
plot(v, add = TRUE)
```


Looks good!  We've plotted the original data in the correct polar aspect. 

But, the data aren't exactly the same, we've added pixels in the heuristic used by GDAL to determine the grid specification from the extent and resolution of the geolocation array longitude and latitudes. 

```{r compare}
ice
polargrid
```

So, let's try to use the same grid. 

```{r same}
gdalraster::warp(sds,  tf <- tempfile(fileext = ".tif", tmpdir = "/vsimem"), t_srs = "EPSG:3412", 
                cl_arg = c("-ts", 316, 332,
                           
                  "-to", "GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES"))

polargrid <- rast(tf)

polargrid
```


We can't do that without giving them the same extent, but we still don't know what that is for the original data. So let's calculate it. 

```{r calc}
xy <- project(values(c(lon, lat)), to = "EPSG:3412", from = "EPSG:4326")
range(xy[,2])
```


## Throw all that away, ignore everything above.

The problem here is that we can't reconstruct the actual grid in the file, we have to treat it as points in geolocation arrays, and infer something about the grid. Here's the answer: 

```{r answer}
ex <- c(xmin = -3950000,  xmax = 3950000, ymin  = -3950000, ymax = 4350000)
diff(ex)[c(1, 3)] / c(316, 332)  ## look familiar?
```

```{r set_extent}
set_ext <- function(x, ex) {terra::ext(x) <- ex; x}

plot(set_ext(ice, ext(ex)))
plot(v, add = T)

plot(polargrid); plot(v, add = TRUE)
```


Now finally, we get exactly the same answer. 


```{r same2}
gdalraster::warp(sds,  tf <- tempfile(fileext = ".tif", tmpdir = "/vsimem"), t_srs = "EPSG:3412", 
                cl_arg = c("-ts", 316, 332, "-te", ex[1], ex[3], ex[2], ex[4],
                           
                  "-to", "GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES"))

polargrid <- rast(tf)

polargrid
polargrid - set_ext(ice, ext(ex))
# class       : SpatRaster 
# size        : 332, 316, 1  (nrow, ncol, nlyr)
# resolution  : 25000, 25000  (x, y)
# extent      : -3950000, 3950000, -3950000, 4350000  (xmin, xmax, ymin, ymax)
# coord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) 
# source(s)   : memory
# varname     : fileb328ade0cec2 
# name        : fileb328ade0cec2 
# min value   :                0 
# max value   :                0 
```

But how did we do that? We plucked some magic numbers out of the air. We can't obtain those four numbers from the lon lat arrays, we can't find them in the file, they aren't in the metadata or the website. We just know, because NSIDC sea ice products are standard on a 3412 grid at 25km resolution. 

This is an entropy problem. 


