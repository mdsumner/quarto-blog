{
  "hash": "f18cb5950afa3d9fe3c5715fa2d3a26b",
  "result": {
    "markdown": "---\ntitle: \"GDAL and image tile, the {ceramic} package\"\nauthor: \"Michael D. Sumner\"\ndate: \"2022-12-09\"\ncategories: [news, code]\ndraft: true\n---\n\n\nA new version of [{ceramic}](https://hypertidy.github.io/ceramic/) is now on CRAN, version 0.8.0. \n\n\nThe package exists for two purpose \n\n1. to download tiles from image servers\n2. to load raster data from image servers\n\n\nNOTE: we need a Mapbox key for the Mapbox servers see, please see /perm_storage/home/mdsumner/R/x86_64-pc-linux-gnu-library/4.2/ceramic/help/get_api_key at [get_api_key()](https://hypertidy.github.io/ceramic/reference/get_api_key.html). \n\n\nThe original versions of ceramic didn't really separate these tasks but the new version does. \n\n\n## Get raster data from online\n\nWe can read satellite imagery or elevation with a central point and a buffer (in metres). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ceramic)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: terra\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nterra 1.7.23\n```\n:::\n\n```{.r .cell-code}\npt <- cbind(147.3257, -42.8826)\n\n(im <- cc_location(pt, buffer = c(15000, 25000)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 960, 576, 3  (nrow, ncol, nlyr)\nresolution  : 52.08333, 52.08333  (x, y)\nextent      : 16385222, 16415222, -5319119, -5269119  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / Pseudo-Mercator (EPSG:3857) \nsource(s)   : memory\ncolors RGB  : 1, 2, 3 \nnames       : red, green, blue \nmin values  :   0,     0,    0 \nmax values  : 255,   255,  252 \n```\n:::\n\n```{.r .cell-code}\n(el <- cc_elevation(pt, buffer = c(15000, 25000)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 960, 576, 1  (nrow, ncol, nlyr)\nresolution  : 52.08333, 52.08333  (x, y)\nextent      : 16385222, 16415222, -5319119, -5269119  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / Pseudo-Mercator (EPSG:3857) \nsource(s)   : memory\nname        :  lyr.1 \nmin value   :   -1.9 \nmax value   : 1264.9 \n```\n:::\n\n```{.r .cell-code}\nop <- par(mfcol = c(1, 2))\nplot(el, legend = F); plot(im, add = TRUE); plot(el, legend = F, \n                                                 col = hcl.colors(64)[tail(seq_len(64), 45)])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hobart-image-1.png){width=672}\n:::\n\n```{.r .cell-code}\npar(op)\n```\n:::\n\nThese raster objects are in terra 'SpatRaster' format (older ceramic used raster package). \n\nThese use the Mapbox 'mapbox.satellite' and 'mapbox-terrain-rgb' tile servers. \n\n## Get raster tiles from online\n\nIf we want the actual tiles, we can use the original `get_tiles()` function. (In older versions `cc_location()` and `cc_elevation()` would *invoke* `get_tiles`, but no longer). \n\n::: {.cell}\n\n```{.r .cell-code}\npt <- cbind(147.3257, -42.8826)\n\nimtiles <- get_tiles(pt, buffer = c(15000, 25000))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPreparing to download: 24 tiles at zoom = 12 from \nhttps://api.mapbox.com/v4/mapbox.satellite/\n```\n:::\n\n```{.r .cell-code}\nstr(imtiles)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ files : chr [1:24] \"/perm_storage/home/mdsumner/.cache/.ceramic/api.mapbox.com/v4/mapbox.satellite/12/3722/2586.jpg\" \"/perm_storage/home/mdsumner/.cache/.ceramic/api.mapbox.com/v4/mapbox.satellite/12/3723/2586.jpg\" \"/perm_storage/home/mdsumner/.cache/.ceramic/api.mapbox.com/v4/mapbox.satellite/12/3724/2586.jpg\" \"/perm_storage/home/mdsumner/.cache/.ceramic/api.mapbox.com/v4/mapbox.satellite/12/3725/2586.jpg\" ...\n $ tiles :List of 2\n  ..$ tiles:'data.frame':\t24 obs. of  2 variables:\n  .. ..$ x: int [1:24] 3722 3723 3724 3725 3722 3723 3724 3725 3722 3723 ...\n  .. ..$ y: int [1:24] 2586 2586 2586 2586 2587 2587 2587 2587 2588 2588 ...\n  .. ..- attr(*, \"out.attrs\")=List of 2\n  .. .. ..$ dim     : Named int [1:2] 4 6\n  .. .. .. ..- attr(*, \"names\")= chr [1:2] \"x\" \"y\"\n  .. .. ..$ dimnames:List of 2\n  .. .. .. ..$ x: chr [1:4] \"x=3722\" \"x=3723\" \"x=3724\" \"x=3725\"\n  .. .. .. ..$ y: chr [1:6] \"y=2586\" \"y=2587\" \"y=2588\" \"y=2589\" ...\n  ..$ zoom : int 12\n  ..- attr(*, \"class\")= chr \"tile_grid\"\n $ extent: num [1:4] 16385222 16415222 -5319119 -5269119\n```\n:::\n\n```{.r .cell-code}\neltiles <- get_tiles(pt, buffer = c(15000, 25000))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPreparing to download: 24 tiles at zoom = 12 from \nhttps://api.mapbox.com/v4/mapbox.satellite/\n```\n:::\n\n```{.r .cell-code}\nhead(gsub(ceramic::ceramic_cache(), \"\",  eltiles$files))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/api.mapbox.com/v4/mapbox.satellite/12/3722/2586.jpg\"\n[2] \"/api.mapbox.com/v4/mapbox.satellite/12/3723/2586.jpg\"\n[3] \"/api.mapbox.com/v4/mapbox.satellite/12/3724/2586.jpg\"\n[4] \"/api.mapbox.com/v4/mapbox.satellite/12/3725/2586.jpg\"\n[5] \"/api.mapbox.com/v4/mapbox.satellite/12/3722/2587.jpg\"\n[6] \"/api.mapbox.com/v4/mapbox.satellite/12/3723/2587.jpg\"\n```\n:::\n:::\n\nAnd to see what tiles we have we can materialize their footprint in [wk::rct()](https://paleolimbot.github.io/wk/reference/rct.html) form, this is way more efficient than having to use polygons.\n\n::: {.cell}\n\n```{.r .cell-code}\nzoomtiles <- ceramic::ceramic_tiles(imtiles$tiles$zoom)\n## sub out the ones we just triggered\nzoomtiles <- dplyr::filter(zoomtiles, fullname %in% imtiles$files)\nrc <- ceramic::tiles_to_polygon(zoomtiles)\nplot(rc)\nplot(ext(im), add = TRUE)  ## see the image from above is not the tiles, but the buffer around a point\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rct-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(read_tiles(pt, buffer = c(15000, 25000)))  ## but we can read thos tiles exactly\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPreparing to download: 24 tiles at zoom = 12 from \nhttps://api.mapbox.com/v4/mapbox.satellite/\n```\n:::\n\n```{.r .cell-code}\nplot(rc, add = TRUE, border = \"white\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rct-2.png){width=672}\n:::\n:::\n\n\n## Diverse query inputs\n\nFinally, we can use a point and buffer to get imagery, or we can use a spatial object, currently supported are objects from {geos}, {wk}, {terra}, {sf}, {sp}, {raster}, and {stars}. \n\nHere's an example. \n\n::: {.cell}\n\n```{.r .cell-code}\nwkarea <- wk::rct(xmin = -0, ymin = 15, xmax = 40, ymax = 55, crs = \"OGC:CRS84\")\nplot(cc_location(wkarea))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/wk-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(cc_elevation(wkarea), col = grey.colors(128))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/wk-2.png){width=672}\n:::\n:::\n\nPrevious versions of `cc_location()` and `cc_elevation()` were stuck with only 'zoom' and 'max_tiles' arguments, these make sense when you restrict exactly to the available tiles but when you just want a given area and a resolution, 'dimension' is more appropriate. \n\nBy default, the dimension is chosen relative to the graphics device.  But, we can also specify exactly what we want. (Use zero for one of the dimensions to let the system figure out an appropriate size for the query you have). \n\n::: {.cell}\n\n```{.r .cell-code}\ncc_location(wkarea)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 960, 754, 3  (nrow, ncol, nlyr)\nresolution  : 5909.027, 5909.027  (x, y)\nextent      : 0, 4455406, 1327548, 7000214  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / Pseudo-Mercator (EPSG:3857) \nsource(s)   : memory\ncolors RGB  : 1, 2, 3 \nnames       : red, green, blue \nmin values  :   0,     0,    0 \nmax values  : 255,   255,  255 \n```\n:::\n\n```{.r .cell-code}\ncc_location(wkarea, dimension = c(400, 700))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 700, 400, 3  (nrow, ncol, nlyr)\nresolution  : 11131.95, 8103.809  (x, y)\nextent      : 0, 4452780, 1327548, 7000214  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / Pseudo-Mercator (EPSG:3857) \nsource(s)   : memory\ncolors RGB  : 1, 2, 3 \nnames       : red, green, blue \nmin values  :   0,     0,    0 \nmax values  : 255,   255,  255 \n```\n:::\n\n```{.r .cell-code}\ncc_location(wkarea, c(1024, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 960, 754, 3  (nrow, ncol, nlyr)\nresolution  : 5909.027, 5909.027  (x, y)\nextent      : 0, 4455406, 1327548, 7000214  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / Pseudo-Mercator (EPSG:3857) \nsource(s)   : memory\ncolors RGB  : 1, 2, 3 \nnames       : red, green, blue \nmin values  :   0,     0,    0 \nmax values  : 255,   255,  255 \n```\n:::\n:::\n\n## Some other improvements\n\n\n* it's faster, for loading reads data from image servers directly with the GDAL warper API\n* we have separation of tile downloading and interaction from raster loading via GDAL\n* we don't materialize tiles as polygons, we have the tile description, or the compact `rct` representation\n* new functions `read_tiles()`, `unpack_rgb()`, \n\nSee the full list of changes here: https://hypertidy.github.io/ceramic/news/index.html\n\nceramic is my final CRAN package that had direct dependencies on rgdal, rgeos, or maptools - in some ways it was the most challenging for me and had loomed as a problem for some time. But, I've progressed my own tool kit well in the time and I learnt a lot with this update. \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}