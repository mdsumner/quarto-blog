{
  "hash": "373a459f356e3548d9b7531aef3cbd1d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Coordinates broken in  NetCDF\"\nauthor: \"Michael Sumner\"\nformat: html\ndate: \"2025-09-04\"\neditor: source\ncategories: [news, code]\ndraft: true\n---\n\n\n\n## A NetCDF file\n\nThere's a NetCDF file at this URL: \n\n```\n\"https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\n```\n\nIt's fairly straightforward: \n\n```\nnetcdf CS2WFA_25km_201007 {\ndimensions:\n        y = 332 ;\n        x = 316 ;\n        time = 1 ;\nvariables:\n        float time(time) ;\n                time:long_name = \"time\" ;\n                time:units = \"months since 2000-01-01\" ;\n                time:calendar = \"360_day\" ;\n        double lat(y, x) ;\n                lat:long_name = \"latitude\" ;\n                lat:units = \"degrees_north\" ;\n        double lon(y, x) ;\n                lon:long_name = \"longitude\" ;\n                lon:units = \"degrees_east\" ;\n        double snow_freeboard(time, y, x) ;\n                snow_freeboard:least_significant_digit = 4LL ;\n                snow_freeboard:units = \"m\" ;\n                snow_freeboard:standard_name = \"snow_freeboard\" ;\n                snow_freeboard:description = \"Mean snow (total) freeboard in grid cell\" ;\n        double ice_freeboard(time, y, x) ;\n                ice_freeboard:least_significant_digit = 4LL ;\n                ice_freeboard:units = \"m\" ;\n                ice_freeboard:standard_name = \"ice_freeboard\" ;\n                ice_freeboard:description = \"Mean ice freeboard in grid cell\" ;\n        double snow_depth(time, y, x) ;\n                snow_depth:least_significant_digit = 4LL ;\n                snow_depth:units = \"m\" ;\n                snow_depth:standard_name = \"snow_depth\" ;\n                snow_depth:description = \"Mean snow depth on sea ice in grid cell\" ;\n        double sea_ice_concentration(time, y, x) ;\n                sea_ice_concentration:least_significant_digit = 4LL ;\n                sea_ice_concentration:units = \"1\" ;\n                sea_ice_concentration:standard_name = \"sea_ice_area_fraction\" ;\n                sea_ice_concentration:description = \"Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\" ;\n\n// global attributes:\n                :title = \"Antarctic sea ice physical properties obtained from CryoSat-2 using the CS2WFA algorithm\" ;\n                :institution = \"NASA GSFC Cryospheric Sciences Laboratory and University of Maryland-College Park\" ;\n                :history = \"File created on November 15, 2022, 12:09:06\" ;\n\ngroup: sea_ice_thickness {\n  variables:\n        double sea_ice_thickness(time, y, x) ;\n                sea_ice_thickness:least_significant_digit = 4LL ;\n                sea_ice_thickness:units = \"m\" ;\n                sea_ice_thickness:standard_name = \"sea_ice_thickness\" ;\n                sea_ice_thickness:description = \"Mean sea ice thickness in grid cell\" ;\n        double sea_ice_thickness_70percent_threshold(time, y, x) ;\n                sea_ice_thickness_70percent_threshold:least_significant_digit = 4LL ;\n                sea_ice_thickness_70percent_threshold:units = \"m\" ;\n                sea_ice_thickness_70percent_threshold:standard_name = \"sea_ice_thickness_70percent_threshold\" ;\n                sea_ice_thickness_70percent_threshold:description = \"Mean sea ice thickness in grid cell found using the 70% power threshold retracking algorithm\" ;\n        double sea_ice_thickness_zero_icefreeboard(time, y, x) ;\n                sea_ice_thickness_zero_icefreeboard:least_significant_digit = 4LL ;\n                sea_ice_thickness_zero_icefreeboard:units = \"m\" ;\n                sea_ice_thickness_zero_icefreeboard:standard_name = \"sea_ice_thickness_zero_icefreeboard\" ;\n                sea_ice_thickness_zero_icefreeboard:description = \"Mean sea ice thickness in grid cell found using the zero-ice-freeboard assumption\" ;\n        double sea_ice_thickness_uncertainty(time, y, x) ;\n                sea_ice_thickness_uncertainty:least_significant_digit = 4LL ;\n                sea_ice_thickness_uncertainty:units = \"m\" ;\n                sea_ice_thickness_uncertainty:standard_name = \"sea_ice_thickness_uncertainty\" ;\n                sea_ice_thickness_uncertainty:description = \"Mean systematic sea ice thickness uncertainty in grid cell\" ;\n  } // group sea_ice_thickness\n\ngroup: density {\n  variables:\n        double ice_density(time, y, x) ;\n                ice_density:least_significant_digit = 4LL ;\n                ice_density:units = \"kg m-3\" ;\n                ice_density:standard_name = \"seasonal_sea_ice_density\" ;\n                ice_density:description = \"Seasonal value of sea ice density\" ;\n        double snow_density(time, y, x) ;\n                snow_density:least_significant_digit = 4LL ;\n                snow_density:units = \"kg m-3\" ;\n                snow_density:standard_name = \"seasonal_snow_density\" ;\n                snow_density:description = \"Seasonal value of snow density\" ;\n        double seawater_density(time, y, x) ;\n                seawater_density:least_significant_digit = 4LL ;\n                seawater_density:units = \"kg m-3\" ;\n                seawater_density:standard_name = \"seasonal_seawater_density\" ;\n                seawater_density:description = \"Seasonal value of seawater density\" ;\n  } // group density\n}\n```\n\nThere's a root group with two variables defined in time,y,x and another two groups with further variables on that same grid. \n\nEach data array is 316x332x1 and we can tell that every lon,lat pair is stored explicitly. This fits a convention in NetCDF where time is \"unlimited\" and we're only looking\nat a subset of an overall time series, that could well be continually generated day to day still now. \n\n\nLet's investigate the coordinates. We'll use GDAL via a commonly used wrapper in R, its 'vsicurl' protocol to stream from the internet, and declare the driver explicitly (lest we get the less sophisticated HDF5 interpretation). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#dsn <- \"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\ndsn <- \"NETCDF:../CS2WFA_25km_201007.nc\"\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nterra 1.8.62\n```\n\n\n:::\n\n```{.r .cell-code}\nlon <- rast(dsn, \"lon\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in R_nc4_open: No such file or directory\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n```\n\n\n:::\n\n```{.r .cell-code}\nlat <- rast(dsn, \"lat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in R_nc4_open: No such file or directory\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(c(lon, lat))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/coords-1.png){width=672}\n:::\n:::\n\n\n\nWe get a message from terra about \"cells not equally spaced\", which means that when reading an array the geospatial context in GDAL didn't find anything specifying a compact representation of coordinates, but lon and lat *are the coordinates* **as data**, so we can safely ignore this message. \n(There's another message about ncdf4, but ignore that too it's terra try(ing) stuff. )\n\nWe won't pay attention to \"time\", because our file only has one time step. We're interested in these lon,lat coordinates. What does the data itself look like? Again we choose one of the 3D variables (with degenerate 3rd dimension 'time') by name. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nice <- rast(dsn, \"sea_ice_concentration\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in R_nc4_open: No such file or directory\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: [rast] GDAL did not find an extent. Cells not equally spaced?\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(ice)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/data-1.png){width=672}\n:::\n:::\n\n\n\nThat should look familiar, though notice that we don't have any spatial information it's just a matrix in its own index coordinates, 0,316 for x and 0,332 for y. \n\nLet's plot the coordinates. Now we can see our data in a much more spatial-ish context. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxyz <- values(c(lon, lat, ice))\nplot(xyz[,1:2], pch = \".\", col = palr::d_pal(xyz[,3]), asp = 2)\nmaps::map(\"world2\", add = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-1.png){width=672}\n:::\n:::\n\n\n \n \nWe now don't have a nice gridded dataset, it's points in longitude latitude. What can we do to plot it in that nice polar aspect with proper spatial referencing? \n\nLet's have a look at this dataset from a GDAL perspective. Now we use the API package `gdalraster` which gives a lot more control over GDAL itself.  I'm going to skip over interrogating the syntax for a particular array, like we did with terra and 'sea_ice_concentration' above, I construct the subdataset syntax to open. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NETCDF:/vsicurl/https://zenodo.org/records/7327711/files/CS2WFA_25km_201007.nc?download=1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsds <- sprintf(\"%s:sea_ice_concentration\", dsn)\nlibrary(gdalraster)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nGDAL 3.12.0dev-4e2b27da8f (released 2025-08-26), GEOS 3.12.1, PROJ 9.3.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'gdalraster'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:terra':\n\n    rasterize\n```\n\n\n:::\n\n```{.r .cell-code}\nds <- new(GDALRaster, sds)\nds$info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDriver: netCDF/Network Common Data Format\nFiles: ../CS2WFA_25km_201007.nc\nSize is 316, 332\nMetadata:\n  NC_GLOBAL#history=File created on November 15, 2022, 12:09:06\n  NC_GLOBAL#institution=NASA GSFC Cryospheric Sciences Laboratory and University of Maryland-College Park\n  NC_GLOBAL#title=Antarctic sea ice physical properties obtained from CryoSat-2 using the CS2WFA algorithm\n  NETCDF_DIM_EXTRA={time}\n  NETCDF_DIM_time_DEF={1,5}\n  NETCDF_DIM_time_VALUES=126\n  sea_ice_concentration#description=Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\n  sea_ice_concentration#least_significant_digit=4\n  sea_ice_concentration#standard_name=sea_ice_area_fraction\n  sea_ice_concentration#units=1\n  time#calendar=360_day\n  time#long_name=time\n  time#units=months since 2000-01-01\nGeolocation:\n  SRS=GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\n  X_DATASET=NETCDF:\"../CS2WFA_25km_201007.nc\":lon\n  X_BAND=1\n  Y_DATASET=NETCDF:\"../CS2WFA_25km_201007.nc\":lat\n  Y_BAND=1\n  PIXEL_OFFSET=0\n  PIXEL_STEP=1\n  LINE_OFFSET=0\n  LINE_STEP=1\n  GEOREFERENCING_CONVENTION=PIXEL_CENTER\nCorner Coordinates:\nUpper Left  (    0.0,    0.0)\nLower Left  (    0.0,  332.0)\nUpper Right (  316.0,    0.0)\nLower Right (  316.0,  332.0)\nCenter      (  158.0,  166.0)\nBand 1 Block=316x332 Type=Float64, ColorInterp=Undefined\n  NoData Value=9.969209968386869e+36\n  Unit Type: 1\n  Metadata:\n    NETCDF_VARNAME=sea_ice_concentration\n    least_significant_digit=4\n    units=1\n    standard_name=sea_ice_area_fraction\n    description=Mean sea ice concentration in grid cell, from Bootstrap V3 concentration algorithm (Comiso, 2017 https://doi.org/10.5067/7Q8HCCWS4I0R)\n    NETCDF_DIM_time=126\n```\n\n\n:::\n:::\n\n\n\nThe interesting part of that output is under \"Geolocation:\". We can see that while GDAL doesn't have spatial referencing for this array, it does seem to know that's it's possible because of the X_DATASET and Y_DATASET. These can be used by the GDAL warper API (warp means \"reprojection\" or \"reshaping\" for an image) in order to resolve to a spatial dataset. So let's warp. \n\nWe don't have to specifying the geolocation arrays, we saw that GDAL already knows this. We'll write conveniently to a temporary virtual \"file\" so we can avoid more cleanup. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdalraster::warp(sds,  tf <- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(icegrid <- rast(tf))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/warp-1.png){width=672}\n:::\n\n```{.r .cell-code}\nicegrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 127, 902, 1  (nrow, ncol, nlyr)\nresolution  : 0.398722, 0.3987662  (x, y)\nextent      : 0.164645, 359.8119, -89.80441, -39.1611  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb833358a66fe0.tif \nname        : fileb833358a66fe0 \n```\n\n\n:::\n:::\n\n\n\nWe indeed now have a spatial grid, a raster. But perhaps we don't like the 0,360 convention. We can set the target extent, GDAL had to figure one out from the input geolocation arrays, and it will usually do a good job but it's really our responsibility to specify what we want for reproducibility in later workflows. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdalraster::warp(sds,  tf <- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\", \n                 cl_arg = c(\"-te\", -180, -90, 180, -39, \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(icegrid <- rast(tf))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/extent-1.png){width=672}\n:::\n\n```{.r .cell-code}\nicegrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 194, 1371, 1  (nrow, ncol, nlyr)\nresolution  : 0.2625821, 0.2628866  (x, y)\nextent      : -180, 180, -90, -39  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb83331998b3c1.tif \nname        : fileb83331998b3c1 \n```\n\n\n:::\n:::\n\n\n\nAnother thing that is also our responsibility is the dimensions of the grid and the resolution, obviously this an extent are all interlinked so we augment our bounding box / extent setting with a nice clean resolution. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdalraster::warp(sds,  tf <- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:4326\", \n                 cl_arg = c(\"-te\", -180, -90, 180, -39, \"-tr\", 0.25, 0.25,\n                            \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(icegrid <- rast(tf))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/extent2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nicegrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 204, 1440, 1  (nrow, ncol, nlyr)\nresolution  : 0.25, 0.25  (x, y)\nextent      : -180, 180, -90, -39  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : fileb8333650693df.tif \nname        : fileb8333650693df \n```\n\n\n:::\n:::\n\n\n\nThat is all well and nice, and we've quietly demonstrated some of the key powers of GDAL: \n\n- virtualization\n- warping with heuristics to a CRS\n- warping with a grid specification, and using geolocation arrays to guide the grid-resolving process\n- setting grid specification with any of crs, extent(bbox), resolution, dimension, and allowing GDAL to internally wrap from 0,360 context to -180,180\n\n\nBut, we still don't have that nice polar aspect we saw from the raw array above. So we change CRS. 'EPSG:3412' is a Polar Stereographic map projection on the south pole, commonly used for standard sea ice products. As a grid this has nice properties, that don't require edge-wrap for a matrix model, it's true scale at approximately where the coastline of Antarctica is, and it preserves shape (this means not all cells are exactly the same size, but they're close enough for where the sea ice is). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdalraster::warp(sds,  tf <- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(polargrid <- rast(tf))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/polargrid-1.png){width=672}\n:::\n\n```{.r .cell-code}\npolargrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 348, 332, 1  (nrow, ncol, nlyr)\nresolution  : 24999.84, 24999.84  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb83334e8575d1.tif \nname        : fileb83334e8575d1 \n```\n\n\n:::\n:::\n\n\n\nTo make sure let's get some spatial data to plot with this. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- vect(\"/vsizip//vsicurl/https://github.com/wmgeolab/geoBoundaries/raw/main/releaseData/CGAZ/geoBoundariesCGAZ_ADM0.zip\", \n     query = \"SELECT shapeGroup FROM geoBoundariesCGAZ_ADM0 WHERE shapeGroup IN ('ATA')\")\nv <- crop(v, ext(-180, 180, -84, 0)) ## small hack to remove the pole seam\nv <- project(v, \"EPSG:3412\")\nplot(polargrid)\nplot(v, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/spatial-1.png){width=672}\n:::\n:::\n\n\n\n\nLooks good!  We've plotted the original data in the correct polar aspect. \n\nBut, the data aren't exactly the same, we've added pixels in the heuristic used by GDAL to determine the grid specification from the extent and resolution of the geolocation array longitude and latitudes. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nice\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 1, 1  (x, y)\nextent      : 0, 316, 0, 332  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource      : CS2WFA_25km_201007.nc:sea_ice_concentration \nvarname     : sea_ice_concentration (sea_ice_area_fraction) \nname        : sea_ice_concentration \nunit        :                     1 \n```\n\n\n:::\n\n```{.r .cell-code}\npolargrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 348, 332, 1  (nrow, ncol, nlyr)\nresolution  : 24999.84, 24999.84  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb83334e8575d1.tif \nname        : fileb83334e8575d1 \n```\n\n\n:::\n:::\n\n\n\nSo, let's try to use the same grid. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdalraster::warp(sds,  tf <- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-ts\", 316, 332,\n                           \n                  \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\npolargrid <- rast(tf)\n\npolargrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 26265.66, 26204.65  (x, y)\nextent      : -3950080, 4349868, -4337584, 4362361  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb8333755a1d6f.tif \nname        : fileb8333755a1d6f \n```\n\n\n:::\n:::\n\n\n\n\nWe can't do that without giving them the same extent, but we still don't know what that is for the original data. So let's calculate it. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxy <- project(values(c(lon, lat)), to = \"EPSG:3412\", from = \"EPSG:4326\")\nrange(xy[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3937527  4337533\n```\n\n\n:::\n:::\n\n\n\n\n## Throw all that away, ignore everything above.\n\nThe problem here is that we can't reconstruct the actual grid in the file, we have to treat it as points in geolocation arrays, and infer something about the grid. Here's the answer: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex <- c(xmin = -3950000,  xmax = 3950000, ymin  = -3950000, ymax = 4350000)\ndiff(ex)[c(1, 3)] / c(316, 332)  ## look familiar?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n xmax  ymax \n25000 25000 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset_ext <- function(x, ex) {terra::ext(x) <- ex; x}\n\nplot(set_ext(ice, ext(ex)))\nplot(v, add = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/set_extent-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(polargrid); plot(v, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/set_extent-2.png){width=672}\n:::\n:::\n\n\n\n\nNow finally, we get exactly the same answer. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdalraster::warp(sds,  tf <- tempfile(fileext = \".tif\", tmpdir = \"/vsimem\"), t_srs = \"EPSG:3412\", \n                cl_arg = c(\"-ts\", 316, 332, \"-te\", ex[1], ex[3], ex[2], ex[4],\n                           \n                  \"-to\", \"GEOLOC_NORMALIZE_LONGITUDE_MINUS_180_PLUS_180=YES\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\npolargrid <- rast(tf)\n\npolargrid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 25000, 25000  (x, y)\nextent      : -3950000, 3950000, -3950000, 4350000  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource      : fileb833318ec58b9.tif \nname        : fileb833318ec58b9 \n```\n\n\n:::\n\n```{.r .cell-code}\npolargrid - set_ext(ice, ext(ex))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: [-] CRS do not match\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 332, 316, 1  (nrow, ncol, nlyr)\nresolution  : 25000, 25000  (x, y)\nextent      : -3950000, 3950000, -3950000, 4350000  (xmin, xmax, ymin, ymax)\ncoord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \nsource(s)   : memory\nvarname     : fileb833318ec58b9 \nname        : fileb833318ec58b9 \nmin value   :                 0 \nmax value   :                 0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# class       : SpatRaster \n# size        : 332, 316, 1  (nrow, ncol, nlyr)\n# resolution  : 25000, 25000  (x, y)\n# extent      : -3950000, 3950000, -3950000, 4350000  (xmin, xmax, ymin, ymax)\n# coord. ref. : NSIDC Sea Ice Polar Stereographic South (EPSG:3412) \n# source(s)   : memory\n# varname     : fileb328ade0cec2 \n# name        : fileb328ade0cec2 \n# min value   :                0 \n# max value   :                0 \n```\n:::\n\n\n\nBut how did we do that? We plucked some magic numbers out of the air. We can't obtain those four numbers from the lon lat arrays, we can't find them in the file, they aren't in the metadata or the website. We just know, because NSIDC sea ice products are standard on a 3412 grid at 25km resolution. \n\nThis is an entropy problem. \n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}