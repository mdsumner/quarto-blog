{
  "hash": "ed0fa088736835ae3bc29f1b3c20cd77",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Conservative regridding with GDAL (?)\"\nauthor: \"Michael Sumner\"\neditor: source\ndate: \"2024-12-11\"\ncategories: [news, code]\n---\n\n\n\nCan GDAL do conservative re-gridding?   For cases of regular grid to regular grid, yes I think it can. \n\nPlease note that I'm using tools I'm comfortable with, because I wrote them. I will reframe in other tools\nand other languages in time. For some reason I'd been blocked on understanding this issue. \n\n\n## Simple grid with four values\n\nTake a grid, 2x2 with values 1,2,3,4 that sums to `10` and warp it to a new size. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## target\ndm <- c(2, 2)\n\ng1 <- matrix(c(1, 2, 3, 4), dm[2], dm[1])\ne1 <- c(-1, 1, -1, 1)\n\nlibrary(vapour)\nlibrary(terra)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nterra 1.7.83\n```\n\n\n:::\n\n```{.r .cell-code}\n## we need this so we can use MEM: via dsn::mem()\nSys.setenv(GDAL_MEM_ENABLE_OPEN = \"YES\")\n\n\n## dsn::mem generates a Memory raster, \n## gdal_raster_data is the warper, here we get identity\nsg <- gdal_raster_data(dsn::mem(g1, extent = e1, projection = \"EPSG:4326\"))\n\nunique(sg[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(sg[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n## spatialize for easy plotting\ntor <- function(x) {\n \n  dm <- attr(x, \"dimension\")[2:1]\n  r <- terra::rast(terra::ext(attr(x, \"extent\")), ncols = dm[1], nrows = dm[2], crs = attr(x, \"projection\"), \n                   vals = x[[1]])\n  r\n}\n\nr <- \"sum\"\n\n##   (always use mem() \"live\" to avoid the garbage collector, and only for Float64 I'm afraid)\n\n\n## now use the same extent but reduce pixel size\ntg <- gdal_raster_data(dsn::mem(g1, extent = e1, projection = \"EPSG:4326\"), target_ext = e1,\n                         target_dim = dm * 8, resample = r)\n\nstr(tg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ : num [1:256] 0.0156 0.0156 0.0156 0.0156 0.0156 ...\n - attr(*, \"dimension\")= num [1:2] 16 16\n - attr(*, \"extent\")= num [1:4] -1 1 -1 1\n - attr(*, \"projection\")= chr \"GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AU\"| __truncated__\n```\n\n\n:::\n:::\n\n\n\nSo we have a lot more values as we resized from 2x2 to 16x16. \n\nIt still looks the same, but the overall quantity has been distributed. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(tor(tg), main = r)\n## draw boundaries on\nabline(v = vaster::x_corner(dm * 8, e1), h = vaster::y_corner(dm * 8, e1))\n```\n\n::: {.cell-output-display}\n![](conservative_regrid_files/figure-html/resize-1.png){width=672}\n:::\n\n```{.r .cell-code}\nprint(sum(tg[[1]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\n## our sum of 10 was distributed across 256 pixels\nunique(tg[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.015625 0.031250 0.046875 0.062500\n```\n\n\n:::\n:::\n\n\n\nNow a different example, an actual map projection change. \n\nBut, gawd ... there's a bug here. WIP\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## now try reprojecting our unit 1x1 longlat grid to LAEA centred a few degrees east and north\ncrs <- \"+proj=laea +lon_0=5 +lat_0=0\"\n## reproject the extent, we use a densified boundary to find the new extent\nprex <- reproj::reproj_extent(c(-1, 1, -1, 1), crs, source = \"EPSG:4326\")\nnewg <- gdal_raster_data(dsn::mem(g1, extent = e1, projection = \"EPSG:4326\"), \n                         target_ext = prex, target_res = c(10000, 10000), target_crs = crs, resample = \"sum\", options = \"-tap\")\nplot(tor(newg))\n```\n\n::: {.cell-output-display}\n![](conservative_regrid_files/figure-html/reproj-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsum(newg[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n\nAnd what about trying to return, of course this can only be approximate (I want to know how this compares to other tools.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## what if we go the other way, \n\nnewdm <- attr(newg, \"dimension\")\nnewext <- attr(newg, \"extent\")\nx <- gdal_raster_data(dsn::mem(matrix(newg[[1]],newdm[2], byrow = TRUE),  extent = newext, projection = crs), \n                 target_dim = dm, target_ext = e1, target_crs = \"EPSG:4326\", resample = \"sum\")\nplot(tor(x))\n```\n\n::: {.cell-output-display}\n![](conservative_regrid_files/figure-html/reverse-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsum(x[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9.496864\n```\n\n\n:::\n:::\n",
    "supporting": [
      "conservative_regrid_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}