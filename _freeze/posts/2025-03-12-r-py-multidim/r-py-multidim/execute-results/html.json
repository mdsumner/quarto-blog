{
  "hash": "aec28a004675cbb9d1db1e79b81d72d6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"GDAL multidim and cloud-ready ZARR\"\nauthor: \"Michael Sumner\"\nformat: html\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n## The GDAL API\n\nI have been working on a better understanding of the [GDAL multidimensional model](https://gdal.org/en/stable/user/multidim_raster_data_model.html) and to do that really needs a closer look at the GDAL API itself. \n\nThis post demonstrates loading the GDAL API via its Python bindings into R. We connect to a modern \"cloud-ready\" ZARR dataset, find out some details about its contents and then convert from its native multidimensional form to a more classic 2D raster model, then use that to create a map from Sentinel 2 imagery. \n\nWe don't go very deep into any part, but just want to show a quick tour of some parts of GDAL that don't get as much attention as deserved (IMO). \nI'm using a very recent version of GDAL, which might mean some code doesn't work for you. If that's the case please let me know and I can explore alternatives and identify when/how the newer features will be more available. There are some echoes here of an older post I made about GDAL in R: https://www.hypertidy.org/posts/2017-09-01_gdal-in-r/\n\n## ZARR and the European Space Agency (ESA)\n\nThe ESA is moving Copernicus to [ZARR](https://zarr.dev), launching its [Earth Observation Processing Framework (EOPF) data format (Zarr)](https://zarr.eopf.copernicus.eu/). ZARR is \"a community project to develop specifications and software for storage of large N-dimensional typed arrays\".  \n\nA ZARR is a dataset consisting of trees of array chunks stored (usually) in object storage and indexed by fairly simple JSON metadata that describes how those chunks align together in one potentially very large array. The idea is that all the metadata lives upfront in instantly readable JSON, and changes made to the dataset (extending it each day as new data arrives) affects only the relevant chunks and the small parts of the JSON. This is different to a long list of NetCDFs that grows every day, where the metadata is self-contained for each file and there is no overarching abstraction for the entire file set. \n\nZARR is usually in object storage, and loaded by datacube software such as [xarray](https://xarray.dev). It's not intended to be zipped into a huge file and downloaded or read, the real power lies in the entire dataset being lazy, and understood by software that needs just one data set description (url, or S3 path, etc). \n\n## ESA sample Zarr datasets\n\nThe ESA provide a set of example ZARRs that are available in zip files: \n\nhttps://eopf-public.s3.sbg.perf.cloud.ovh.net/product.html\n\nWe choose one that is described by this URL: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl <- \"https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\"\n```\n:::\n\n\n\n## GDAL urls and zip files\n\nGDAL doesn't force us to download data, but we need some syntax to leverage its remote capabilities in the simplest way. The Virtual File System (VSI) allows\nus to declare special sources like zip files `/vsizip/` and urls `/vsicurl/`, which we can chain together. With ZARR we also need careful quoting of the description, and we declare the ZARR driver upfront. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(dsn <- sprintf('ZARR:\"/vsizip//vsicurl/%s\"', url))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ZARR:\\\"/vsizip//vsicurl/https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\\\"\"\n```\n\n\n:::\n:::\n\n\n\n## GDAL and multidimensional datasets\n\nGDAL has a multidimensional mode for data sources that aren't \"imagery\" in the traditional sense. (If we open one of these datasets in \"classic\" mode we end up with a lot of bands on a 2D raster, or potentially many bands on many *sub*datasets within a more general container. Zarr is a container format, much like HDF5 and NetCDF). \n\nMultidimensional mode is avaible in the API via `OpenEx()` and declaring type `OF_MULTIDIM_RASTER`. \n\nTo actually load this python library we use [{reticulate} `py_require()`](https://posit.co/blog/reticulate-1-41/) which drives the awesome [Python uv](https://docs.astral.sh/uv/) package manager. \n\n(For some reason the pypi name of the package is \"gdal\", but the actual module is obtained with \"osgeo.gdal\"). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreticulate::py_require(\"gdal\")\ngdal <- reticulate::import(\"osgeo.gdal\")\ngdal$UseExceptions()\n\nsample(names(gdal), 40)  ## see that we have a huge coverage of the underlying API, 544 elements at time of writing\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"TileIndexOptions\"                       \n [2] \"GDT_Int64\"                              \n [3] \"Translate\"                              \n [4] \"GetSignedURL\"                           \n [5] \"VSI_STAT_SET_ERROR_FLAG\"                \n [6] \"DMD_MIMETYPE\"                           \n [7] \"FileFromMemBuffer\"                      \n [8] \"ExceptionMgr\"                           \n [9] \"RegenerateOverview\"                     \n[10] \"GDAL_GCP_GCPPixel_set\"                  \n[11] \"GARIO_ERROR\"                            \n[12] \"CXT_Attribute\"                          \n[13] \"RasterizeLayer\"                         \n[14] \"CPLE_OutOfMemory\"                       \n[15] \"DCAP_DEFAULT_FIELDS\"                    \n[16] \"VectorTranslateOptions\"                 \n[17] \"CPLE_AssertionFailed\"                   \n[18] \"GCI_SWIRBand\"                           \n[19] \"DMD_MULTIDIM_DATASET_CREATIONOPTIONLIST\"\n[20] \"DIM_TYPE_TEMPORAL\"                      \n[21] \"GVM_Max\"                                \n[22] \"GARIO_COMPLETE\"                         \n[23] \"GOA2GetAuthorizationURL\"                \n[24] \"AllRegister\"                            \n[25] \"OpenShared\"                             \n[26] \"VSIErrorReset\"                          \n[27] \"GDAL_DMD_RELATIONSHIP_FLAGS\"            \n[28] \"CE_Warning\"                             \n[29] \"wrapper_GDALFootprintDestName\"          \n[30] \"GCI_SAR_Ku_Band\"                        \n[31] \"GFT_Integer\"                            \n[32] \"Attribute\"                              \n[33] \"GetDriver\"                              \n[34] \"CreateRasterAttributeTableFromMDArrays\" \n[35] \"GetPaletteInterpretationName\"           \n[36] \"VSIFErrorL\"                             \n[37] \"GARIO_PENDING\"                          \n[38] \"PopErrorHandler\"                        \n[39] \"GDAL_GCP_Info_set\"                      \n[40] \"GCI_AlphaBand\"                          \n```\n\n\n:::\n:::\n\n\n\nThe API elements chain in the usual way that works in python with 'object.element.thing.etc' syntax uses R's `$` accessor. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdal$Dimension$GetIndexingVariable\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<function Dimension.GetIndexingVariable at 0x7f0422add760>\n signature: (self, *args) -> 'GDALMDArrayHS *'\n```\n\n\n:::\n:::\n\n\n\n## Open the data\n\nIt's not very exciting yet. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nds <- gdal$OpenEx(dsn, gdal$OF_MULTIDIM_RASTER)\nds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<osgeo.gdal.Dataset; proxy of <Swig Object of type 'GDALDatasetShadow *' at 0x7f0422c6f420> >\n```\n\n\n:::\n:::\n\n\n\nTo actually find out what's in there we have to traverse a tree of potentially nested \"groups\" that organize actual datasets in a hierarchy. \n\nGet the root group and dive in, it's very tediuous but shows some of what is there. There might be MDArrays in a group, or there might just be more groups. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrg <- ds$GetRootGroup()\nrg$GetMDArrayNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n\n```{.r .cell-code}\nrg$GetGroupNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"conditions\"   \"measurements\" \"quality\"     \n```\n\n\n:::\n\n```{.r .cell-code}\ng1 <- rg$OpenGroup(\"quality\")\ng1$GetMDArrayNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n\n```{.r .cell-code}\ng1$GetGroupNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"l1c_quicklook\" \"mask\"         \n```\n\n\n:::\n\n```{.r .cell-code}\ng2 <- g1$OpenGroup(\"l1c_quicklook\")\ng2$GetMDArrayNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n\n```{.r .cell-code}\ng2$GetGroupNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"r10m\"\n```\n\n\n:::\n\n```{.r .cell-code}\ng3 <- g2$OpenGroup(\"r10m\")\ng3$GetMDArrayNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"band\" \"x\"    \"y\"    \"tci\" \n```\n\n\n:::\n\n```{.r .cell-code}\ng3$GetGroupNames()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n:::\n\n\n\nFinally we got to actual data, we recognize 'tci' as being the quicklook RGB of Sentinel 2. \n\nTo avoid tedium write a quick recursive function to find all the MDArray, at each level use `GetFullName()` which provides the cumulative path to where we are in the tree. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_all_mdnames <- function(rootgroup) {\n  groups <- rootgroup$GetGroupNames()\n  groupname <- rootgroup$GetFullName()\n  amd <- rootgroup$GetMDArrayNames()\n  md <- sprintf(\"%s/%s\", groupname, amd)\n  md <- c(md, unlist(lapply(groups, \\(.g) get_all_mdnames(rootgroup$OpenGroup(.g)))))\n  md\n}\n\nget_all_mdnames(ds$GetRootGroup())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] \"/conditions/geometry/angle\"                        \n  [2] \"/conditions/geometry/band\"                         \n  [3] \"/conditions/geometry/detector\"                     \n  [4] \"/conditions/geometry/x\"                            \n  [5] \"/conditions/geometry/y\"                            \n  [6] \"/conditions/geometry/mean_sun_angles\"              \n  [7] \"/conditions/geometry/mean_viewing_incidence_angles\"\n  [8] \"/conditions/geometry/sun_angles\"                   \n  [9] \"/conditions/geometry/viewing_incidence_angles\"     \n [10] \"/conditions/mask/detector_footprint/r10m/x\"        \n [11] \"/conditions/mask/detector_footprint/r10m/y\"        \n [12] \"/conditions/mask/detector_footprint/r10m/b02\"      \n [13] \"/conditions/mask/detector_footprint/r10m/b03\"      \n [14] \"/conditions/mask/detector_footprint/r10m/b04\"      \n [15] \"/conditions/mask/detector_footprint/r10m/b08\"      \n [16] \"/conditions/mask/detector_footprint/r20m/x\"        \n [17] \"/conditions/mask/detector_footprint/r20m/y\"        \n [18] \"/conditions/mask/detector_footprint/r20m/b05\"      \n [19] \"/conditions/mask/detector_footprint/r20m/b06\"      \n [20] \"/conditions/mask/detector_footprint/r20m/b07\"      \n [21] \"/conditions/mask/detector_footprint/r20m/b11\"      \n [22] \"/conditions/mask/detector_footprint/r20m/b12\"      \n [23] \"/conditions/mask/detector_footprint/r20m/b8a\"      \n [24] \"/conditions/mask/detector_footprint/r60m/x\"        \n [25] \"/conditions/mask/detector_footprint/r60m/y\"        \n [26] \"/conditions/mask/detector_footprint/r60m/b01\"      \n [27] \"/conditions/mask/detector_footprint/r60m/b09\"      \n [28] \"/conditions/mask/detector_footprint/r60m/b10\"      \n [29] \"/conditions/mask/l1c_classification/r60m/x\"        \n [30] \"/conditions/mask/l1c_classification/r60m/y\"        \n [31] \"/conditions/mask/l1c_classification/r60m/b00\"      \n [32] \"/conditions/meteorology/cams/latitude\"             \n [33] \"/conditions/meteorology/cams/longitude\"            \n [34] \"/conditions/meteorology/cams/aod1240\"              \n [35] \"/conditions/meteorology/cams/aod469\"               \n [36] \"/conditions/meteorology/cams/aod550\"               \n [37] \"/conditions/meteorology/cams/aod670\"               \n [38] \"/conditions/meteorology/cams/aod865\"               \n [39] \"/conditions/meteorology/cams/bcaod550\"             \n [40] \"/conditions/meteorology/cams/duaod550\"             \n [41] \"/conditions/meteorology/cams/isobaricInhPa\"        \n [42] \"/conditions/meteorology/cams/number\"               \n [43] \"/conditions/meteorology/cams/omaod550\"             \n [44] \"/conditions/meteorology/cams/ssaod550\"             \n [45] \"/conditions/meteorology/cams/step\"                 \n [46] \"/conditions/meteorology/cams/suaod550\"             \n [47] \"/conditions/meteorology/cams/surface\"              \n [48] \"/conditions/meteorology/cams/time\"                 \n [49] \"/conditions/meteorology/cams/valid_time\"           \n [50] \"/conditions/meteorology/cams/z\"                    \n [51] \"/conditions/meteorology/ecmwf/latitude\"            \n [52] \"/conditions/meteorology/ecmwf/longitude\"           \n [53] \"/conditions/meteorology/ecmwf/isobaricInhPa\"       \n [54] \"/conditions/meteorology/ecmwf/msl\"                 \n [55] \"/conditions/meteorology/ecmwf/number\"              \n [56] \"/conditions/meteorology/ecmwf/r\"                   \n [57] \"/conditions/meteorology/ecmwf/step\"                \n [58] \"/conditions/meteorology/ecmwf/surface\"             \n [59] \"/conditions/meteorology/ecmwf/tco3\"                \n [60] \"/conditions/meteorology/ecmwf/tcwv\"                \n [61] \"/conditions/meteorology/ecmwf/time\"                \n [62] \"/conditions/meteorology/ecmwf/u10\"                 \n [63] \"/conditions/meteorology/ecmwf/v10\"                 \n [64] \"/conditions/meteorology/ecmwf/valid_time\"          \n [65] \"/measurements/reflectance/r10m/x\"                  \n [66] \"/measurements/reflectance/r10m/y\"                  \n [67] \"/measurements/reflectance/r10m/b02\"                \n [68] \"/measurements/reflectance/r10m/b03\"                \n [69] \"/measurements/reflectance/r10m/b04\"                \n [70] \"/measurements/reflectance/r10m/b08\"                \n [71] \"/measurements/reflectance/r20m/x\"                  \n [72] \"/measurements/reflectance/r20m/y\"                  \n [73] \"/measurements/reflectance/r20m/b05\"                \n [74] \"/measurements/reflectance/r20m/b06\"                \n [75] \"/measurements/reflectance/r20m/b07\"                \n [76] \"/measurements/reflectance/r20m/b11\"                \n [77] \"/measurements/reflectance/r20m/b12\"                \n [78] \"/measurements/reflectance/r20m/b8a\"                \n [79] \"/measurements/reflectance/r60m/x\"                  \n [80] \"/measurements/reflectance/r60m/y\"                  \n [81] \"/measurements/reflectance/r60m/b01\"                \n [82] \"/measurements/reflectance/r60m/b09\"                \n [83] \"/measurements/reflectance/r60m/b10\"                \n [84] \"/quality/l1c_quicklook/r10m/band\"                  \n [85] \"/quality/l1c_quicklook/r10m/x\"                     \n [86] \"/quality/l1c_quicklook/r10m/y\"                     \n [87] \"/quality/l1c_quicklook/r10m/tci\"                   \n [88] \"/quality/mask/r10m/x\"                              \n [89] \"/quality/mask/r10m/y\"                              \n [90] \"/quality/mask/r10m/b02\"                            \n [91] \"/quality/mask/r10m/b03\"                            \n [92] \"/quality/mask/r10m/b04\"                            \n [93] \"/quality/mask/r10m/b08\"                            \n [94] \"/quality/mask/r20m/x\"                              \n [95] \"/quality/mask/r20m/y\"                              \n [96] \"/quality/mask/r20m/b05\"                            \n [97] \"/quality/mask/r20m/b06\"                            \n [98] \"/quality/mask/r20m/b07\"                            \n [99] \"/quality/mask/r20m/b11\"                            \n[100] \"/quality/mask/r20m/b12\"                            \n[101] \"/quality/mask/r20m/b8a\"                            \n[102] \"/quality/mask/r60m/x\"                              \n[103] \"/quality/mask/r60m/y\"                              \n[104] \"/quality/mask/r60m/b01\"                            \n[105] \"/quality/mask/r60m/b09\"                            \n[106] \"/quality/mask/r60m/b10\"                            \n```\n\n\n:::\n:::\n\n\n\nHappily, we see our target MDArray name in there `/quality/l1c_quicklook/r10m/tci`. \n\n\n## Actual data\n\nFinally let's get some data out. We can obtain the MDArray now by full name and find out some properties. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreticulate::py_require(\"gdal\")\ngdal <- reticulate::import(\"osgeo.gdal\")\ngdal$UseExceptions()\n\ndsn <- \"ZARR:\\\"/vsizip//vsicurl/https://eopf-public.s3.sbg.perf.cloud.ovh.net/eoproducts/S02MSIL1C_20230629T063559_0000_A064_T3A5.zarr.zip\\\"\"\n\nds <- gdal$OpenEx(dsn, gdal$OF_MULTIDIM_RASTER)\nrg <- ds$GetRootGroup()\nmdname <- \"/quality/l1c_quicklook/r10m/tci\"\nmd <- rg$OpenMDArrayFromFullname(mdname)\nmd$GetDimensionCount()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\nTraverse the dimensions to get their sizes and names. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(md$GetDimensions(), \\(.d) .d$GetSize(), 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     3 10980 10980\n```\n\n\n:::\n\n```{.r .cell-code}\nvapply(md$GetDimensions(), \\(.d) .d$GetName(), \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"band\" \"y\"    \"x\"   \n```\n\n\n:::\n:::\n\n\n\n\nExplore some metadata attributes. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmnames <- vapply(md$GetAttributes(), \\(.a) .a$GetName(), \"\")\n\n(meta <- setNames(lapply(md$GetAttributes(), \\(.a) unlist(.a$Read())), mnames))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$long_name\n[1] \"TCI: True Color Image\"\n\n$`proj:bbox`\n[1]  300000 4490220  409800 4600020\n\n$`proj:epsg`\n[1] 32636\n\n$`proj:shape`\n[1] 10980 10980\n\n$`proj:transform`\n[1]      10       0  300000       0     -10 4600020       0       0       1\n\n$`proj:wkt2`\n[1] \"PROJCS[\\\"WGS 84 / UTM zone 36N\\\",GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]],PROJECTION[\\\"Transverse_Mercator\\\"],PARAMETER[\\\"latitude_of_origin\\\",0],PARAMETER[\\\"central_meridian\\\",33],PARAMETER[\\\"scale_factor\\\",0.9996],PARAMETER[\\\"false_easting\\\",500000],PARAMETER[\\\"false_northing\\\",0],UNIT[\\\"metre\\\",1,AUTHORITY[\\\"EPSG\\\",\\\"9001\\\"]],AXIS[\\\"Easting\\\",EAST],AXIS[\\\"Northing\\\",NORTH],AUTHORITY[\\\"EPSG\\\",\\\"32636\\\"]]\"\n```\n\n\n:::\n:::\n\n\n\nWe see that the CRS information is in there, but sadly while the geotransform of the data is maintained when we convert to classic raster the CRS does not make the journey (the geotransform is just the image bbox intermingled with its resolution in a mathematical abstraction used in matrix manipulation). \n\n\nA multidim raster can be converted to classic form, either in whole or after applying a `$GetView()` operation that acts like numpy '[:]' array subsetting. \n\nWhen converting to classic raster we specify the x, then y dimensions of the dataset, which from multdim convention are in reverse order.  (Note that dimension 0 is the \"3rd\" dimension in normal thinking, here that dimension is \"band\" or a dimension for each of red, green, blue in the quicklook image). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc <- md$AsClassicDataset(2L, 1L)\ntr <- unlist(cc$GetGeoTransform())\ndm <- c(cc$RasterXSize, cc$RasterYSize)\ncc$GetSpatialRef() ## empty, so we retrieve from the attributes\ncrs <- cc$GetMetadata()[[\"proj:wkt2\"]]\n```\n:::\n\n\n\nNow, I used `reproj_extent` to convert the dataset's bbox to one in longlat, but I won't share that here, we'll just use the result so our map is a little more familiar.  The source data xy bbox is `xmin: 300000 ymin: 4490220  xmax: 409800 ymax:4600020`, and we take small section of that which is this in longitude latitude: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# xmin,xmax,ymin,ymax converted below to bbox \nex <- c(31.689, 31.774, 40.665, 40.724)\n```\n:::\n\n\n\nTo warp the imagery to this region we first need to set the CRS properly on the dataset, so translate to a temporary VRT and use that dataset for the next step. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndsvrt <- gdal$Translate(tempfile(fileext = \".vrt\", tmpdir = \"/vsimem\"), cc, options = c(\"-a_srs\", crs))\ntf <- tf <- \"/vsimem/result.tif\"\nww <- gdal$Warp(tf, dsvrt,  dstSRS = \"EPSG:4326\", outputBounds = ex[c(1, 3, 2, 4)])\nww$Close()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\nFinally we can read the image, plot it, obtain some contextual data and be assured that our map is correct. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gdalraster)\ndata <- read_ds(new(GDALRaster, tf))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(osmdata)\nx <- opq(ex[c(1, 3, 2, 4)]) |> add_osm_feature(key = \"highway\") |> osmdata_sf()\n\nlibrary(sf)\nplot_raster(data)\nplot(x$osm_lines[0], add = TRUE, col = \"hotpink\")\n```\n\n::: {.cell-output-display}\n![](r-py-multidim_files/figure-html/osm-1.png){width=672}\n:::\n:::\n\n\n\n\n## Summary\n\nWe had a look at GDAL multidimensional API, converting a 3D dataset to classic raster, augmenting the missing CRS information on a virtual copy and then warping an image to a familiar map context. \n\nThere is ongoing work to bring the full GDAL API to R in [{gdalraster}](https://github.com/USDAForestService/gdalraster), and in-development version of gdalraster to add the `GDALMultiDimRaster` class and helpers: https://github.com/mdsumner/gdalraster/tree/multidimnew. \n\nPlease get in touch if any of this is of interest!\n\n",
    "supporting": [
      "r-py-multidim_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}