{
  "hash": "943c7922ee456ea85ef713876f02289a",
  "result": {
    "markdown": "---\ntitle:  \"R matrices and image\"\ndate:   \"2014-04-17\"\ncategories: [code]\ntags: [R, matrix]\n---\n\n\n## Matrix and image\n\nIn R, matrices are ordered row-wise: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(m <- matrix(1:12, nrow = 3, ncol = 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n:::\n\n\nThe *image()* function presents this as the transpose of what we see printed. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[] <- 0\nm[2, 1] <- -10\nm[3, 2] <- 30\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]  -10    0    0    0\n[3,]    0   30    0    0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nt(m[, ncol(m):1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n[3,]    0    0   30\n[4,]    0  -10    0\n```\n:::\n:::\n\n\n\n\n\n> ... Notice that image interprets the z matrix as a table of f(x[i], y[j]) values, \n> so that the x axis corresponds to row number and the y axis to column number, \n> with column 1 at the bottom, i.e. a __90 degree counter-clockwise rotation__ of \n> the conventional printed layout of a matrix.\n> ...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage(m)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Data placement with image()\n\nThis is fairly obvious, each cell is painted as a discrete block with cell centres evenly spaced between 0 and 1. \n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:12, 3)\nimage(m)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nWe didn't give it any coordinates to position the image, so it made some up. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage(m, main = \"input coordinates are cell centres\")\nxx <- seq.int(0, 1, length.out = nrow(m))\nyy <- seq.int(0, 1, length.out = ncol(m))\nabline(h = yy, v = xx, lty = 2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\nThis lends itself to a convenient data structure. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- list(x = xx, y = yy, z = m)\nimage(dat)\ntext(expand.grid(xx, yy), lab = as.vector(m))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## points(expand.grid(xx, yy))\n```\n:::\n\n\nThe function *image()* has some hidden tricks. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nxcorner <- seq.int(0, 1, length.out = nrow(m) + 1L)\nycorner <- seq.int(0, 1, length.out = ncol(m) + 1L)\nprint(xcorner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0000000 0.3333333 0.6666667 1.0000000\n```\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(ycorner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.00 0.25 0.50 0.75 1.00\n```\n:::\n:::\n\n```\n## [1] 0.00 0.25 0.50 0.75 1.00\n```\n\n::: {.cell}\n\n```{.r .cell-code}\nimage(xcorner, ycorner, m, main = \"input coordinates are cell corners\")\nabline(h = ycorner, v = xcorner)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nWe can even use non-regular coordinates. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nycorner <- 1.5^seq_along(ycorner)\nimage(xcorner, ycorner, m)\nabline(h = ycorner, v = xcorner)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n##    Under the hood\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(image.default)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, \n    length.out = ncol(z)), z, zlim = range(z[is.finite(z)]), \n    xlim = range(x), ylim = range(y), col = hcl.colors(12, \"YlOrRd\", \n        rev = TRUE), add = FALSE, xaxs = \"i\", yaxs = \"i\", xlab, \n    ylab, breaks, oldstyle = FALSE, useRaster, ...) \n{\n    if (missing(z)) {\n        if (!missing(x)) {\n            if (is.list(x)) {\n                z <- x$z\n                y <- x$y\n                x <- x$x\n            }\n            else {\n                if (is.null(dim(x))) \n                  stop(\"argument must be matrix-like\")\n                z <- x\n                x <- seq.int(0, 1, length.out = nrow(z))\n            }\n            if (missing(xlab)) \n                xlab <- \"\"\n            if (missing(ylab)) \n                ylab <- \"\"\n        }\n        else stop(\"no 'z' matrix specified\")\n    }\n    else if (is.list(x)) {\n        xn <- deparse1(substitute(x))\n        if (missing(xlab)) \n            xlab <- paste0(xn, \"$x\")\n        if (missing(ylab)) \n            ylab <- paste0(xn, \"$y\")\n        y <- x$y\n        x <- x$x\n    }\n    else {\n        if (missing(xlab)) \n            xlab <- if (missing(x)) \n                \"\"\n            else deparse1(substitute(x))\n        if (missing(ylab)) \n            ylab <- if (missing(y)) \n                \"\"\n            else deparse1(substitute(y))\n    }\n    if (any(!is.finite(x)) || any(!is.finite(y))) \n        stop(\"'x' and 'y' values must be finite and non-missing\")\n    if (any(diff(x) <= 0) || any(diff(y) <= 0)) \n        stop(\"increasing 'x' and 'y' values expected\")\n    if (!is.matrix(z)) \n        stop(\"'z' must be a matrix\")\n    if (!typeof(z) %in% c(\"logical\", \"integer\", \"double\")) \n        stop(\"'z' must be numeric or logical\")\n    if (length(x) > 1 && length(x) == nrow(z)) {\n        dx <- 0.5 * diff(x)\n        x <- c(x[1L] - dx[1L], x[-length(x)] + dx, x[length(x)] + \n            dx[length(x) - 1])\n    }\n    if (length(y) > 1 && length(y) == ncol(z)) {\n        dy <- 0.5 * diff(y)\n        y <- c(y[1L] - dy[1L], y[-length(y)] + dy, y[length(y)] + \n            dy[length(y) - 1L])\n    }\n    if (missing(breaks)) {\n        nc <- length(col)\n        if (!missing(zlim) && (any(!is.finite(zlim)) || diff(zlim) < \n            0)) \n            stop(\"invalid z limits\")\n        if (diff(zlim) == 0) \n            zlim <- if (zlim[1L] == 0) \n                c(-1, 1)\n            else zlim[1L] + c(-0.4, 0.4) * abs(zlim[1L])\n        z <- (z - zlim[1L])/diff(zlim)\n        zi <- if (oldstyle) \n            floor((nc - 1) * z + 0.5)\n        else floor((nc - 1e-05) * z + 1e-07)\n        zi[zi < 0 | zi >= nc] <- NA\n    }\n    else {\n        if (length(breaks) != length(col) + 1) \n            stop(\"must have one more break than colour\")\n        if (any(!is.finite(breaks))) \n            stop(\"'breaks' must all be finite\")\n        if (is.unsorted(breaks)) {\n            warning(\"unsorted 'breaks' will be sorted before use\")\n            breaks <- sort(breaks)\n        }\n        zi <- .bincode(z, breaks, TRUE, TRUE) - 1L\n    }\n    if (!add) \n        plot(xlim, ylim, xlim = xlim, ylim = ylim, type = \"n\", \n            xaxs = xaxs, yaxs = yaxs, xlab = xlab, ylab = ylab, \n            ...)\n    if (length(x) <= 1) \n        x <- par(\"usr\")[1L:2]\n    if (length(y) <= 1) \n        y <- par(\"usr\")[3:4]\n    if (length(x) != nrow(z) + 1 || length(y) != ncol(z) + 1) \n        stop(\"dimensions of z are not length(x)(-1) times length(y)(-1)\")\n    check_irregular <- function(x, y) {\n        dx <- diff(x)\n        dy <- diff(y)\n        (length(dx) && !isTRUE(all.equal(dx, rep(dx[1], length(dx))))) || \n            (length(dy) && !isTRUE(all.equal(dy, rep(dy[1], length(dy)))))\n    }\n    if (missing(useRaster)) {\n        useRaster <- getOption(\"preferRaster\", FALSE)\n        if (useRaster && check_irregular(x, y)) \n            useRaster <- FALSE\n        if (useRaster) {\n            useRaster <- FALSE\n            ras <- dev.capabilities(\"rasterImage\")$rasterImage\n            if (identical(ras, \"yes\")) \n                useRaster <- TRUE\n            if (identical(ras, \"non-missing\")) \n                useRaster <- all(!is.na(zi))\n        }\n    }\n    if (useRaster) {\n        if (check_irregular(x, y)) \n            stop(gettextf(\"%s can only be used with a regular grid\", \n                sQuote(\"useRaster = TRUE\")), domain = NA)\n        if (!is.character(col)) {\n            col <- as.integer(col)\n            if (any(!is.na(col) & col < 0L)) \n                stop(\"integer colors must be non-negative\")\n            col[col < 1L] <- NA_integer_\n            p <- palette()\n            col <- p[((col - 1L)%%length(p)) + 1L]\n        }\n        zc <- col[zi + 1L]\n        dim(zc) <- dim(z)\n        zc <- t(zc)[ncol(zc):1L, , drop = FALSE]\n        rasterImage(as.raster(zc), min(x), min(y), max(x), max(y), \n            interpolate = FALSE)\n    }\n    else .External.graphics(C_image, x, y, zi, col)\n    invisible()\n}\n<bytecode: 0x56211bec3418>\n<environment: namespace:graphics>\n```\n:::\n:::\n\n\n\nThis is  like looping with *rect()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nop <- par(mfrow = c(1, 2))\n## life is hard\ncols <- topo.colors(25)\nscale <- round((m - min(m))/diff(range(m)) * (length(cols) - 1) + 1)\nplot(NA, type = \"n\", xlim = range(xcorner), ylim = range(ycorner), asp = 1)\nfor (i in seq_along(xcorner[-1L])) {\n    for (j in seq_along(ycorner[-1L])) {\n        rect(xleft = xcorner[i], ybottom = ycorner[j], xright = xcorner[i + \n            1L], ytop = ycorner[j + 1L], col = cols[scale[i, j]], angle = 45 * \n            (i + j)%%2, density = 20, lwd = 2)\n    }\n    \n}\n\n## life is good\nimage(list(x = xcorner, y = ycorner, z = m), col = topo.colors(25), asp = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(op)\n```\n:::\n\n\n## \"Raster graphics\" (not the *raster* package)\n \nRelatively recently native image-graphics support was added to R. \n\nOld style\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:12, nrow = 3)\nxcorner <- seq.int(0, 1, length.out = nrow(m) + 1L)\nycorner <- seq.int(0, 1, length.out = ncol(m) + 1L)\nimage(xcorner, ycorner, m, col = topo.colors(25))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}