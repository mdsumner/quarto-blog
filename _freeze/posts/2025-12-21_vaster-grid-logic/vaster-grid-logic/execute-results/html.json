{
  "hash": "f61c4a0f94db817ba3d2215efee0d72d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Raster logic without pixels\"\nauthor: \"Michael Sumner\"\nformat: html\ndate: 2025-12-21\neditor: visual\ncategories: [code, news]\n---\n\n\n\n\n\n## Raster logic is in our software\n\nEvery geospatial package that works with grids has *raster logic* inside. The old {raster} package in R established powerful abstraction functions and now {terra} includes an improved suite of those, the {stars} package has its own internally, GDAL obviously uses these abstractions deeply, and xarray and many other Python packages also provide this. There is similar logic built into R's matrix and array functions, its visualization `image()` function, and the newer `rasterImage()`.\n\nIs there a problem? This logic is almost always coupled to a data structure. You can't use raster's `cellFromXY()` without a RasterLayer. You can't use terra's `xyFromCell()` or `cells()` without a SpatRaster. Many packages have embedded this reinvented wheel, and to more or less degree lock the wheel inside a bigger machine.\n\nThe logic itself is beautifully simple: given a grid with certain dimensions (ncol, nrow) and a spatial extent (xmin, xmax, ymin, ymax, or identically 'bbox' xmin,ymin,xmax,ymax), you can compute everything else. Cell indices, row/column positions, coordinate centres and corners, cropping and snapping—all of it flows from six numbers and some basic arithmetic.\n\nThat's what [{vaster}](https://hypertidy.github.io/vaster/) extracts: the logic alone, without any data. (This logic of course is not especially 2D and extends into n-dimensional concepts as well illustrated by xarray and others, but please let's park that from our discussion here.)\n\n## R already knows this (sort of)\n\nR's base graphics already embody two distinct models for placing gridded data in space.\n\n### The `image()` model: rectilinear coordinates\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- volcano[1:10, 1:15]\nx <- seq(0, 1, length.out = nrow(m) + 1)\ny <- seq(0, 2, length.out = ncol(m) + 1)\n\nimage(x, y, m, col = terrain.colors(12))\n```\n\n::: {.cell-output-display}\n![](vaster-grid-logic_files/figure-html/image-model-1.png){width=672}\n:::\n:::\n\n\n\nThe `image()` function takes explicit coordinate vectors for cell boundaries. This is the *rectilinear* model—you define where every edge falls. It's flexible (cells don't need to be square, or even uniform), but it means carrying around those vectors.\n\nNotice `x` has `nrow(m) + 1` elements, and `y` has `ncol(m) + 1`. These are *edge* coordinates, not centres. The function figures out that a 10×15 matrix needs 11×16 edges. (Centres are also a valid input for `image()`, it quietly handles either case of 'n' or 'n+1', note this has implications for interpretation of a grid but that takes us away from the main topic here).\n\n### The `rasterImage()` model: bounding box placement\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(NA, xlim = c(0, 1), ylim = c(0, 2), asp = 1, xlab = \"x\", ylab = \"y\")\nrasterImage(as.raster(scales::rescale(m)), xleft = 0, ybottom = 0, xright = 1, ytop = 2, interpolate = F)\n```\n\n::: {.cell-output-display}\n![](vaster-grid-logic_files/figure-html/rasterImage-model-1.png){width=672}\n:::\n:::\n\n\n\nThe `rasterImage()` function takes a different approach: you hand it an image and four numbers defining the bounding box. The function stretches or compresses the image to fit. This is the *affine* model—the grid is implicitly regular within the box.\n\nThese two models are part of a foundation of all raster handling. GeoTIFFs use the affine model (extent + dimension → implicit coordinates). NetCDF often uses the rectilinear model (explicit coordinate arrays). Both are valid; both are useful; both involve the same underlying logic.\n\n### {ximage}: unifying both models\n\nThere's a sort of frustration in base with `image()` and `rasterImage()`, each has features the other lacks. `image()` handles numeric data with colour palettes and is geared to R's matrix orientation, can create a plot or add to an existing one, but by default will draw into a unit square. `rasterImage()` handles the orientation more aligned to external raster data and graphics, but only works with unit-scaled data or pre-rendered images—no palette mapping, and no plot creation (only adding to an existing plot) .\n\n{ximage} merges the features of both into one function that uses the rasterImage orientation:\n\n``` r\nlibrary(ximage)\n\n## Plot numeric data in GIS orientation with extent\nximage(volcano, extent = c(0, 61, 0, 87), col = terrain.colors(24))\n\n## Or RGB arrays, or nativeRaster, or hex colours—all work\nximage(rgb_array, extent = c(100, 160, -50, -10))\n\n## Add contours that respect the same extent\nxcontour(volcano, extent = c(0, 61, 0, 87), add = TRUE, levels = c(120, 140, 160))\n```\n\nOnce we separate the *data* (a matrix of values) from the *placement* (extent as four numbers), you can handle any input type with the same logic. The orientation confusion disappears because {ximage} adopts the rasterImage convention—the one that matches how GDAL and every other geospatial tool returns data.\n\nThis is {vaster}'s philosophy applied to plotting: the spatial meaning comes from the six numbers (dimension + extent), not from the data structure.\n\n## What vaster provides\n\n{vaster} gives that underlying logic with no attachment to any data format or structure. All you need are dimension and extent (and extent is optional, a sensible default is \\[0,nx\\], \\[0,ny\\] rather than unit-square).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vaster)\n\ndm <- c(40, 20)  # ncol, nrow\nex <- c(100, 160, -50, -10)  # xmin, xmax, ymin, ymax\n\n# Cell centres - implicit from dimension and extent\nx_centre(dm, ex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 100.75 102.25 103.75 105.25 106.75 108.25 109.75 111.25 112.75 114.25\n[11] 115.75 117.25 118.75 120.25 121.75 123.25 124.75 126.25 127.75 129.25\n[21] 130.75 132.25 133.75 135.25 136.75 138.25 139.75 141.25 142.75 144.25\n[31] 145.75 147.25 148.75 150.25 151.75 153.25 154.75 156.25 157.75 159.25\n```\n\n\n:::\n\n```{.r .cell-code}\ny_centre(dm, ex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -49 -47 -45 -43 -41 -39 -37 -35 -33 -31 -29 -27 -25 -23 -21 -19 -17 -15 -13\n[20] -11\n```\n\n\n:::\n:::\n\n\n\nWhat cell contains a given point?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Some arbitrary coordinates\npts <- cbind(x = c(120.5, 145.2, 110.8), \n             y = c(-25.3, -42.1, -15.7))\n\ncell_from_xy(dm, ex, pts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 294 671  88\n```\n\n\n:::\n:::\n\n\n\nWhat are the coordinates of cells 1, 100, and 800?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxy_from_cell(dm, ex, c(1, 100, 800))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1] [,2]\n[1,] 100.75  -11\n[2,] 129.25  -15\n[3,] 159.25  -49\n```\n\n\n:::\n:::\n\n\n\nConvert between row/column and cell index:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cell to row, column\ncell <- 42\nrow_from_cell(dm, cell)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\ncol_from_cell(dm, cell)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Row, column to cell\ncell_from_row_col(dm, row = 3, col = 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 95\n```\n\n\n:::\n:::\n\n\n\nNone of this requires loading imagery or touching files. It's pure computation from first principles.\n\nNote here that indexing is via R's convention: 1-based, both for cell and row and col.\n\n## The snap problem\n\nOne of the most common operations in raster work is \"snapping\"—taking an arbitrary region and aligning it to an existing grid. You want to crop to an area of interest, but you need cell-aligned boundaries.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A reference grid: 3-degree cells covering the globe\nref_dm <- c(30, 10)\nref_ex <- c(-180, 180, -90, 90)\n\n# Some arbitrary region of interest (not aligned to anything)\nroi <- c(15, 154.7, -44.2, -9.8)\n\n# Snap to the reference grid\nsnapped <- vcrop(roi, ref_dm, extent = ref_ex)\nsnapped\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$extent\n[1]  12 156 -54   0\n\n$dimension\n[1] 12  3\n```\n\n\n:::\n:::\n\n\n\nThe result gives you the exact dimension and extent for the crop window, aligned to the reference grid. No data needed—just the numbers.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_extent(ref_ex, border = \"grey\")\nabline(v = x_corner(ref_dm, ref_ex), col = \"grey90\")\nabline(h = y_corner(ref_dm, ref_ex), col = \"grey90\")\n\n# Original ROI (arbitrary)\nplot_extent(roi, border = \"red\", lwd = 2, add = TRUE)\n\n# Snapped ROI (grid-aligned)\nplot_extent(snapped$extent, border = \"blue\", lwd = 2, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](vaster-grid-logic_files/figure-html/snap-plot-1.png){width=672}\n:::\n:::\n\n\n\nThe red box is what we asked for; the blue box is what we get when we respect the grid alignment.\n\n## The geotransform connection\n\nGDAL uses a six-element \"geotransform\" to encode the affine relationship between pixel coordinates and geographic coordinates. This is the workhorse of georeferenced raster data. {vaster} speaks this language:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# From extent and dimension to geotransform\ngt <- extent_dim_to_gt(ex, dm)\ngt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n xmin  xres yskew  ymax xskew  yres \n100.0   1.5   0.0 -10.0   0.0  -2.0 \n```\n\n\n:::\n\n```{.r .cell-code}\n# And back again\ngt_dim_to_extent(gt, dm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nxmin xmin ymax ymax \n 100  160  -50  -10 \n```\n\n\n:::\n:::\n\n\n\nThis matters when you're working directly with GDAL (via {gdalraster}, {vapour}, or Python's osgeo.gdal) and need to set up or interpret raster metadata without constructing heavyweight objects.\n\n## Why does this matter?\n\n1.  **Lightweight tooling**: Sometimes we just need to compute cell indices or snap extents. We shouldn't need to load terra or GDAL for that.\n\n2.  **Cross-package compatibility**: The logic is the same whether you're working with terra, stars, GDAL, or raw arrays. Having it in one place means consistent behaviour everywhere.\n\n3.  **Teaching and understanding**: Separating the logic from the data makes it clearer what raster operations actually *do*. The magic isn't in the file format or the object class—it's in the relationship between dimension and extent.\n\n## The ecosystem: what you can build with pure logic\n\nOnce you separate grid logic from data, interesting things become possible. Here are three packages that build on this foundation, taken (ahem) shamelessly from the hypertidy suite. (I'm not ignoring other important packages in R and Python that use these ideas, but these are chosen to focus on the core idea of what vaster is and why it exists. )\n\n### {fasterize}: fast polygon rasterization\n\n{fasterize} is a high-performance replacement for `raster::rasterize()`. It uses the classic scanline algorithm to burn polygons onto a grid. The original fasterize required an actual RasterLayer as a template—not for its data, but for its six numbers (dimension and extent).\n\n``` r\n## fasterize needs a \"raster\", but really it just needs dimension + extent\nlibrary(fasterize)\nr <- raster::raster(ncol = 1000, nrow = 800, \n                    xmn = 0, xmx = 100, ymn = 0, ymx = 80)\nresult <- fasterize(polygons_sf, r, field = \"value\")\n```\n\nThe raster object is just a vessel for grid metadata, but fasterize also will create an actual numeric matrix in memory - so it has these two limitations at input and output. With raster logic available separately, we can drive the same algorithm with nothing but numbers.\n\n### {controlledburn}: don't materialize, just rasterize\n\n{controlledburn} takes the fasterize algorithm and strips away the last step: instead of filling a raster with values, it returns the *indices* of which cells each polygon covers. The output is run-length encoded scanline segments—start, end, row, polygon_id.\n\n``` r\nlibrary(controlledburn)\nlibrary(vaster)\n\n## Define a grid with just numbers\next <- c(100, 160, -50, -10)\ndm <- c(500, 400)\n\n## Get the cell coverage index, not pixel values\nidx <- burn_polygon(polygons_sf, extent = ext, dimension = dm)\n```\n\nFor a 500,000 × 400,000 grid, materializing a raster would require terabytes. But storing the polygon coverage as run-length scanline indices? Tens of megabytes for typical distributions that real world polygons embody. The grid logic is the same—only the output changes.\n\nThis is the \"cell abstraction\" always implicit in raster operations. We can use these indices for extraction, for streaming aggregation, for anything that doesn't require all pixels to exist at once.\n\n### {grout}: tiling without tiles\n\n{grout} applies the same principle to tiling. Given a grid's dimension and extent, plus a block size, it computes the complete tiling scheme: how many tiles, where each one falls, how much overlap (\"dangle\") occurs when dimensions don't divide evenly.\n\n``` r\nlibrary(grout)\n\n## A raster that's 87 × 61 with 8 × 8 tiles\nscheme <- grout(c(87, 61), extent = c(0, 87, 0, 61), blocksize = c(8, 8))\nscheme\n#> tiles: 11, 8 (x * y = 88)\n#> block: 8, 8\n#> dangle: 1, 3\n#> tile extent: 0, 88, -3, 61 (xmin,xmax,ymin,ymax)\n\n## Get offset/size for each tile (for GDAL RasterIO)\ntile_index(scheme)\n```\n\nNo data loaded. No files opened. Just the arithmetic of how a grid subdivides. This is exactly what you need to drive tiled reading from GDAL, or to generate web map tile pyramids, or to parallelize processing across spatial chunks.\n\n### The common thread\n\nAll three packages share a design principle: **the grid specification is just six numbers, and most operations don't need anything else**.\n\n{fasterize} showed that fast rasterization doesn't need heavy objects—just geometry and grid metadata. {controlledburn} showed you don't even need to materialize pixels—indices are enough. {grout} showed that tiling is pure arithmetic on dimension and extent.\n\n{vaster} is the foundation that makes this all clean. Instead of each package reinventing `cellFromXY()` and friends, they can share a common vocabulary for grid logic.\n\n## Python has the same mix of concepts and tools\n\nThe Python geospatial ecosystem has grappled with the same issues that motivated {vaster}.\n\nA [recent pangeo discussion](https://discourse.pangeo.io/t/comparing-odc-stac-load-and-stackstac-for-raster-composite-workflow/4097) compared `odc.stac` and `stackstac`—two packages for loading satellite imagery into xarray. Despite ostensibly doing the same thing, they produce different results. Why?\n\n**Pixel coordinates: edge or centre?** When you say a pixel is at coordinate (100.0, 200.0), do you mean that's its centre, or its top-left corner? `odc.stac` defaults to centre, `stackstac` defaults to edge. Both are valid conventions; GIS tools tend toward corners, while climate/ocean data tends toward centres. But if you don't know which convention your tool uses, your data shifts by half a pixel.\n\n**Coordinate snapping**: When your requested bounding box doesn't align perfectly with the source grid, what happens? Different tools make different choices about how to snap—and those choices are usually invisible, buried in the library internals.\n\nThese are exactly the questions {vaster} makes explicit. Dimension and extent. Corner or centre. Snap in or snap out. The logic is universal; only the defaults vary.\n\n### xarray's new RasterIndex\n\nThe xarray team recently [announced flexible indexing](https://xarray.dev/blog/flexible-indexing), including a `RasterIndex` that computes coordinates on-the-fly from an affine transform rather than storing explicit coordinate arrays. Sound familiar?\n\nFrom the post:\n\n> For 2D raster images, this function often takes the form of an Affine Transform. The rasterix library extends Xarray with a RasterIndex which computes coordinates for geospatial images such as GeoTiffs via Affine Transform.\n\nThis is the same insight: **coordinates are implicit in dimension and extent**. You don't need to materialize a 7-terabyte coordinate array when six numbers suffice. The xarray team is building infrastructure for raster grid logic itself. \n\nThe Python ecosystem will align around this conceptual foundation—grid logic as well as R and other language. \n\n## The R matrix connection\n\nR's matrices already have most of this logic, just without the spatial semantics. A matrix has dimension (nrow, ncol). When you use `image()` with explicit coordinates, you're adding extent. The `[i, j]` indexing is cell-from-row-column. `which(m > threshold, arr.ind = TRUE)` gives you row-column-from-cell.\n\n{vaster} makes this connection explicit. It treats dimension and extent as first-class inputs, just as R treats matrices as first-class objects. The spatial meaning is in the numbers, not the container.\n\n## Example: raster logic is a simplifying principle\n\nEnough theory! Let's make a map. The following string defines a huge world-coverage image server.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndsn <- \"WMTS:https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/WMTS/1.0.0/WMTSCapabilities.xml,layer=World_Imagery\"\n```\n:::\n\n\n\nSo, obviously we need a huge stack of Python geospatial to make a map image ... or maybe we can just use generic tools and do it in R.\n\nWe're using {gdalraster} here because it's the thinnest wrapper over the GDAL API, but the same calls work through {terra}, {vapour}, or Python's osgeo.gdal. The point isn't the package — it's that the interface is just numbers and strings. I'm still using a mix of tools and plotting ... but that's life. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gdalraster)\nlibrary(ximage)\nds <- new(GDALRaster, dsn)  ## same as terra::rast(dsn) or osgeo.gdal.Open(dsn) or rioxarray.open_rasterio(dsn)\nds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nC++ object of class GDALRaster\n Driver : OGC Web Map Tile Service (WMTS)\n DSN    : WMTS:https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/WMTS/1.0.0/WMTSCapabilities.xml,layer=World_Imagery\n Dim    : 1073741766, 1070224430, 4\n CRS    : WGS 84 / Pseudo-Mercator (EPSG:3857)\n Res    : 0.037323, 0.037323\n Bbox   : -20037507.260427, -19971868.890929, 20037507.248165, 19971868.903191\n```\n\n\n:::\n:::\n\n\n\nWe don't want the whole world and certainly not that much detail, how about Mawson Station in Antarctica, Mawson is at approximately 62.87E and -67.6S.\n\nWe should define a local equal area projection, on Mawson.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprj <- \"+proj=laea +lon_0=62.8742 +lat_0=-67.6033\"\n```\n:::\n\n\n\nWhat is the right extent or bbox for that projection? It's just metres around the *zero-point*, let's go with a range.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- 125000\ntfile <- tempfile(tmpdir = \"/vsimem\", fileext = \".vrt\") ## use GDAL to manage IO and cleanup, same in other tools\nchk <- warp(dsn, tfile, t_srs = prj, cl_arg = c(\"-te\", -b, -b, b, b,  \"-ts\", 1024, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nximage(read_ds(new(GDALRaster, tfile), bands = 1:3), asp = 1)\n```\n\n::: {.cell-output-display}\n![](vaster-grid-logic_files/figure-html/warp-1.png){width=672}\n:::\n:::\n\n\n\nWhat about a different data source, can we see any meaningful data in sea ice at this time of year?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nicedsn <- \"/vsicurl/https://data.seaice.uni-bremen.de/amsr2/asi_daygrid_swath/s3125/2025/dec/Antarctic3125/asi-AMSR2-s3125-20251220-v5.4.tif\"\n\ntfile <- tempfile(tmpdir = \"/vsimem\", fileext = \".vrt\")\nchk <- warp(icedsn, tfile, t_srs = prj, cl_arg = c(\"-te\", -b, -b, b, b,  \"-ts\", 1024, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\ndat <- read_ds(new(GDALRaster, tfile), bands = 1)\ndat[dat > 100] <- NA\n\nximage(dat, col = grey.colors(100), asp = 1)\n```\n\n::: {.cell-output-display}\n![](vaster-grid-logic_files/figure-html/sst-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   1.00   94.00   98.00   90.99  100.00  100.00  576851 \n```\n\n\n:::\n:::\n\n\n\nNot unexpectedly at 3.125km resolution it's a bit sparse on information, but we didn't have to use a different approach to get coincident data. The ice is thick here, to see Mawson at about this time from Sentinel 2 imagery, try [the estinel catalog](https://projects.pawsey.org.au/estinel/catalog/catalog-browser.html?location=Mawson_Station_20m&date=2025-12-18&viewtype=view_q128&sort=alphabetical), click 'ESA' and zoom around for more, you'll see that dark hole in the sea ice). \n\nWhat about the bathymetry? Even at this scale we can see the disparity between bathymetric and topographic detail.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbathdsn <- \"/vsicurl/https://projects.pawsey.org.au/idea-gebco-tif/GEBCO_2024.tif\"\ntfile <- tempfile(tmpdir = \"/vsimem\", fileext = \".vrt\")\nchk <- warp(bathdsn, tfile, t_srs = prj, cl_arg = c(\"-te\", -b, -b, b, b,  \"-ts\", 1024, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nximage(dat <- read_ds(new(GDALRaster, tfile), bands = 1), col = hcl.colors(128), asp = 1)\n```\n\n::: {.cell-output-display}\n![](vaster-grid-logic_files/figure-html/b2-1.png){width=672}\n:::\n:::\n\n\n\nLet's zoom right in, and this time we'll use terra so that adding contours is easy, read the REMA v2 2m topography and add it as contours.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- 3000\ntfile <- tempfile(tmpdir = \"/vsimem\", fileext = \".vrt\")\nchk <- warp(dsn, tfile, t_srs = prj, cl_arg = c(\"-te\", -b, -b, b, b,  \"-ts\", 1024, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nximage(read_ds(new(GDALRaster, tfile), bands = 1:3), asp = TRUE)\n\nremadsn <- \"/vsicurl/https://raw.githubusercontent.com/mdsumner/rema-ovr/main/REMA-2m_dem_ovr.vrt\"\nlibrary(terra)\nr <- rast(ext(-b, b, -b, b), crs = prj, ncols = 1024, nrows = 1024)\ntfile <- tempfile(tmpdir = \"/vsimem\", fileext = \".vrt\")\nchk <- warp(remadsn, tfile, t_srs = prj, cl_arg = c(\"-te\", -b, -b, b, b,  \"-ts\", 1024, 1024))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0...10...20...30...40...50...60...70...80...90...100 - done.\n```\n\n\n:::\n\n```{.r .cell-code}\nrema <- read_ds(new(GDALRaster, tfile), bands = 1)\ncontour(setValues(r, rema), add = TRUE)\n```\n\n::: {.cell-output-display}\n![](vaster-grid-logic_files/figure-html/zoom-1.png){width=672}\n:::\n:::\n\n\n\n## Thanks\n\nHopefully this sparks some interest in the simplicity of raster grid logic and more folks using the GDAL warp api to its full potential. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.1 (2025-06-13)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=en_AU.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_AU.UTF-8        LC_COLLATE=en_AU.UTF-8    \n [5] LC_MONETARY=en_AU.UTF-8    LC_MESSAGES=en_AU.UTF-8   \n [7] LC_PAPER=en_AU.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_AU.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Etc/UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ximage_0.0.0.9012     gdalraster_2.3.0.9007 terra_1.8-80         \n[4] vaster_0.5.0         \n\nloaded via a namespace (and not attached):\n [1] cli_3.6.5          knitr_1.50         rlang_1.1.6        xfun_0.53         \n [5] yyjsonr_0.1.21     jsonlite_2.0.0     glue_1.8.0         bit_4.6.0         \n [9] htmltools_0.5.8.1  scales_1.4.0       rmarkdown_2.29     rappdirs_0.3.3    \n[13] evaluate_1.0.5     fastmap_1.2.0      lifecycle_1.0.4    yaml_2.3.10       \n[17] compiler_4.5.1     nanoarrow_0.7.0-2  codetools_0.2-19   RColorBrewer_1.1-3\n[21] htmlwidgets_1.6.4  Rcpp_1.1.0         rstudioapi_0.15.0  farver_2.1.2      \n[25] digest_0.6.39      wk_0.9.4.9000      R6_2.6.1           dichromat_2.0-0.1 \n[29] parallel_4.5.1     tools_4.5.1        bit64_4.6.0-1      palr_0.4.0        \n[33] xml2_1.5.1        \n```\n\n\n:::\n:::\n",
    "supporting": [
      "vaster-grid-logic_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}